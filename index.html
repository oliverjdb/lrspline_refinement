<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LR B-Spline Refinement Visualization (Single Start)</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .controls {
            width: 300px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .visualization {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        h2 {
            margin-top: 0;
            color: #333;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-weight: 500;
        }
        input, select, button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover {
            background: #005a9e;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        svg {
            border: 1px solid #ddd;
            background: white;
        }
        .info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            color: #1976d2;
            margin-bottom: 20px;
        }
        .bspline-item {
            padding: 5px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .bspline-item:hover {
            background: #f0f0f0;
        }
        .bspline-item.selected {
            border-color: #007acc;
            background: #e3f2fd;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        let nextBSplineId = 0;
        const generateBSplineId = () => nextBSplineId++;
        const resetBSplineIdCounter = () => { nextBSplineId = 0; };

        /**
         * LRBSpline class - represents a single LR B-spline
         * Knot vectors have distinct values (no multiplicity)
         */
        class LRBSpline {
            constructor(knotsU, knotsV, id = null) {
                this.id = id !== null ? id : generateBSplineId();
                this.knotsU = [...knotsU];
                this.knotsV = [...knotsV];
            }

            /**
             * Get the support of this B-spline
             */
            getSupport() {
                return {
                    uMin: this.knotsU[0],
                    uMax: this.knotsU[this.knotsU.length - 1],
                    vMin: this.knotsV[0],
                    vMax: this.knotsV[this.knotsV.length - 1]
                };
            }

            /**
             * Calculate the Greville point (average of interior knots)
             * For degree p with p+2 knots, Greville point is average of middle p knots
             */
            getGrevillePoint() {
                const degreeU = this.knotsU.length - 2;
                const degreeV = this.knotsV.length - 2;
                
                // Average of interior knots (exclude first and last)
                let u = 0;
                for (let i = 1; i <= degreeU; i++) {
                    u += this.knotsU[i];
                }
                u /= degreeU;
                
                let v = 0;
                for (let i = 1; i <= degreeV; i++) {
                    v += this.knotsV[i];
                }
                v /= degreeV;
                
                return { u, v };
            }

            /**
             * Check if a horizontal meshline fully traverses this B-spline's support
             * The meshline must pass through the interior (not on boundary) and
             * span the entire width
             */
            isFullyTraversedByHorizontal(v, uStart, uEnd) {
                const support = this.getSupport();
                const epsilon = 1e-10;
                
                // Check if v is in the interior of the v-support
                if (v <= support.vMin + epsilon || v >= support.vMax - epsilon) {
                    return false;
                }
                
                // Check if the horizontal line spans the entire u-support
                return uStart <= support.uMin + epsilon && uEnd >= support.uMax - epsilon;
            }

            /**
             * Check if a vertical meshline fully traverses this B-spline's support
             */
            isFullyTraversedByVertical(u, vStart, vEnd) {
                const support = this.getSupport();
                const epsilon = 1e-10;
                
                // Check if u is in the interior of the u-support
                if (u <= support.uMin + epsilon || u >= support.uMax - epsilon) {
                    return false;
                }
                
                // Check if the vertical line spans the entire v-support
                return vStart <= support.vMin + epsilon && vEnd >= support.vMax - epsilon;
            }

            splitU(newKnot) {
                const epsilon = 1e-10;
                const degreeU = this.knotsU.length - 2;
                
                const newKnotsU = [...this.knotsU];
                let insertIdx = newKnotsU.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsU.length;
                newKnotsU.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline(
                    newKnotsU.slice(0, degreeU + 2),
                    this.knotsV
                );
                const bspline2 = new LRBSpline(
                    newKnotsU.slice(1, degreeU + 3),
                    this.knotsV
                );
                
                return [bspline1, bspline2];
            }

            splitV(newKnot) {
                const epsilon = 1e-10;
                const degreeV = this.knotsV.length - 2;
                
                const newKnotsV = [...this.knotsV];
                let insertIdx = newKnotsV.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsV.length;
                newKnotsV.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline(
                    this.knotsU,
                    newKnotsV.slice(0, degreeV + 2)
                );
                const bspline2 = new LRBSpline(
                    this.knotsU,
                    newKnotsV.slice(1, degreeV + 3)
                );
                
                return [bspline1, bspline2];
            }
        }

        /**
         * Meshline class - represents a single meshline in the LR mesh
         */
        class Meshline {
            constructor(direction, constant, start, end, id) {
                this.direction = direction; // 'horizontal' or 'vertical'
                this.constant = constant;   // the fixed coordinate
                this.start = start;         // start of the line segment
                this.end = end;             // end of the line segment
                this.id = id;               // unique identifier
            }
        }

        /**
         * Create initial mesh with B-splines
         * numElementsU/V: number of elements in each direction (must be >= degree+1)
         * For degree p with n elements, we get n*p B-splines in that direction
         */
        const createMesh = (degreeU, degreeV, numElementsU, numElementsV) => {
            resetBSplineIdCounter();
            
            const meshlines = [];
            let nextId = 0;
            
            // Create knot vectors with distinct values
            const knotsU = [];
            const knotsV = [];
            
            for (let i = 0; i <= numElementsU; i++) {
                knotsU.push(i / numElementsU);
            }
            for (let i = 0; i <= numElementsV; i++) {
                knotsV.push(i / numElementsV);
            }
            
            // Create meshlines
            for (const v of knotsV) {
                meshlines.push(new Meshline('horizontal', v, 0, 1, nextId++));
            }
            for (const u of knotsU) {
                meshlines.push(new Meshline('vertical', u, 0, 1, nextId++));
            }
            
            // Create initial B-splines
            // For degree p with n+1 knots, we can create n-p B-splines
            // Each B-spline uses p+2 consecutive knots
            const bsplines = [];
            const numBSplinesU = knotsU.length - degreeU - 1;
            const numBSplinesV = knotsV.length - degreeV - 1;
            
            for (let i = 0; i < numBSplinesU; i++) {
                for (let j = 0; j < numBSplinesV; j++) {
                    const localKnotsU = knotsU.slice(i, i + degreeU + 2);
                    const localKnotsV = knotsV.slice(j, j + degreeV + 2);
                    bsplines.push(new LRBSpline(localKnotsU, localKnotsV));
                }
            }

            // Create initial elements (rectangular grid)
            const elements = [];
            for (let i = 0; i < numElementsU; i++) {
                for (let j = 0; j < numElementsV; j++) {
                    elements.push({
                        uMin: knotsU[i],
                        uMax: knotsU[i + 1],
                        vMin: knotsV[j],
                        vMax: knotsV[j + 1]
                    });
                }
            }

            return {
                meshlines,
                bsplines,
                elements,
                degreeU,
                degreeV,
                nextId,
                globalKnotsU: new Set(knotsU),
                globalKnotsV: new Set(knotsV)
            };
        };

        /**
         * Check if a meshline exists at the given position
         */
        const meshlineExists = (mesh, direction, constant, start, end) => {
            const epsilon = 1e-10;
            return mesh.meshlines.some(line =>
                line.direction === direction &&
                Math.abs(line.constant - constant) < epsilon &&
                line.start <= start + epsilon &&
                line.end >= end - epsilon
            );
        };

        /**
         * Get all T-junction endpoints (where local refinements end)
         * The direction stored indicates which direction we want to EXTEND
         * (same direction as the existing line that created the T-junction)
         */
        const getTJunctionEndpoints = (mesh) => {
            const epsilon = 1e-10;
            const endpoints = [];
            
            // Find horizontal meshlines that don't span the full domain
            // At their endpoints, we can continue extending HORIZONTALLY
            const horizontalLines = mesh.meshlines.filter(line => line.direction === 'horizontal');
            for (const line of horizontalLines) {
                // Check if start point is not at domain boundary (u=0)
                if (line.start > epsilon) {
                    // This is a T-junction at the start - can extend horizontally from here
                    endpoints.push({ u: line.start, v: line.constant, direction: 'horizontal', isTJunction: true });
                }
                // Check if end point is not at domain boundary (u=1)
                if (line.end < 1 - epsilon) {
                    // This is a T-junction at the end - can extend horizontally from here
                    endpoints.push({ u: line.end, v: line.constant, direction: 'horizontal', isTJunction: true });
                }
            }
            
            // Find vertical meshlines that don't span the full domain
            // At their endpoints, we can continue extending VERTICALLY
            const verticalLines = mesh.meshlines.filter(line => line.direction === 'vertical');
            for (const line of verticalLines) {
                // Check if start point is not at domain boundary (v=0)
                if (line.start > epsilon) {
                    // This is a T-junction at the start - can extend vertically from here
                    endpoints.push({ u: line.constant, v: line.start, direction: 'vertical', isTJunction: true });
                }
                // Check if end point is not at domain boundary (v=1)
                if (line.end < 1 - epsilon) {
                    // This is a T-junction at the end - can extend vertically from here
                    endpoints.push({ u: line.constant, v: line.end, direction: 'vertical', isTJunction: true });
                }
            }
            
            return endpoints;
        };

        /**
         * Get all valid start points for refinement
         * 
         * Rules:
         * 1. NO points at crossroads (where both horizontal and vertical meshlines exist)
         *    EXCEPT: midpoints between knots are always valid (they're never at crossroads by definition)
         * 2. T-junctions: extend in SAME direction as existing line
         * 3. Points on a single meshline at knot positions: refine PERPENDICULARLY to that meshline
         */
        const getValidStartPoints = (mesh) => {
            const points = [];
            const epsilon = 1e-10;
            const knotsU = [...mesh.globalKnotsU].sort((a, b) => a - b);
            const knotsV = [...mesh.globalKnotsV].sort((a, b) => a - b);
            
            // Helper: check if a horizontal meshline passes through point (u, v)
            const hasHorizontalMeshlineAt = (u, v) => {
                return mesh.meshlines.some(line =>
                    line.direction === 'horizontal' &&
                    Math.abs(line.constant - v) < epsilon &&
                    line.start <= u + epsilon &&
                    line.end >= u - epsilon
                );
            };
            
            // Helper: check if a vertical meshline passes through point (u, v)
            const hasVerticalMeshlineAt = (u, v) => {
                return mesh.meshlines.some(line =>
                    line.direction === 'vertical' &&
                    Math.abs(line.constant - u) < epsilon &&
                    line.start <= v + epsilon &&
                    line.end >= v - epsilon
                );
            };
            
            // Helper: check if point is at a crossroads (both directions have meshlines)
            const isCrossroads = (u, v) => {
                return hasHorizontalMeshlineAt(u, v) && hasVerticalMeshlineAt(u, v);
            };
            
            // Helper: check if point already exists
            const pointExists = (u, v) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon
                );
            };
            
            // CASE 1: Midpoints between V-knots on vertical meshlines → HORIZONTAL refinements
            // These are the standard refinement points (never at crossroads since they're at midpoints)
            for (let j = 0; j < knotsV.length - 1; j++) {
                const midV = (knotsV[j] + knotsV[j + 1]) / 2;
                
                const verticalLines = mesh.meshlines.filter(line =>
                    line.direction === 'vertical' &&
                    line.start <= midV + epsilon &&
                    line.end >= midV - epsilon
                );
                
                verticalLines.forEach(line => {
                    if (!pointExists(line.constant, midV)) {
                        points.push({ u: line.constant, v: midV, direction: 'horizontal' });
                    }
                });
            }
            
            // CASE 2: Midpoints between U-knots on horizontal meshlines → VERTICAL refinements
            for (let i = 0; i < knotsU.length - 1; i++) {
                const midU = (knotsU[i] + knotsU[i + 1]) / 2;
                
                const horizontalLines = mesh.meshlines.filter(line =>
                    line.direction === 'horizontal' &&
                    line.start <= midU + epsilon &&
                    line.end >= midU - epsilon
                );
                
                horizontalLines.forEach(line => {
                    if (!pointExists(midU, line.constant)) {
                        points.push({ u: midU, v: line.constant, direction: 'vertical' });
                    }
                });
            }
            
            // CASE 3: T-junction endpoints (extend in SAME direction as existing line)
            const tJunctions = getTJunctionEndpoints(mesh);
            for (const tj of tJunctions) {
                if (!pointExists(tj.u, tj.v)) {
                    points.push(tj);
                }
            }
            
            // CASE 4: Points on vertical meshlines at V-knot positions (not midpoints)
            // These allow HORIZONTAL refinements (perpendicular to the vertical line)
            // But NOT at crossroads, and NOT if already added
            for (const line of mesh.meshlines) {
                if (line.direction === 'vertical') {
                    for (const v of knotsV) {
                        if (v >= line.start - epsilon && v <= line.end + epsilon) {
                            const u = line.constant;
                            if (!isCrossroads(u, v) && !pointExists(u, v)) {
                                points.push({ u, v, direction: 'horizontal' });
                            }
                        }
                    }
                }
            }
            
            // CASE 5: Points on horizontal meshlines at U-knot positions (not midpoints)
            // These allow VERTICAL refinements (perpendicular to the horizontal line)
            // But NOT at crossroads, and NOT if already added
            for (const line of mesh.meshlines) {
                if (line.direction === 'horizontal') {
                    for (const u of knotsU) {
                        if (u >= line.start - epsilon && u <= line.end + epsilon) {
                            const v = line.constant;
                            if (!isCrossroads(u, v) && !pointExists(u, v)) {
                                points.push({ u, v, direction: 'vertical' });
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Get valid end points given a start point
         * For T-junctions: the direction is already set to the perpendicular direction we want to extend
         * For regular points: find intersections with perpendicular meshlines
         */
        const getValidEndPoints = (mesh, startPoint) => {
            const points = [];
            const direction = startPoint.direction;
            const epsilon = 1e-10;
            
            if (direction === 'horizontal') {
                // Extending horizontally - find vertical meshlines
                const v = startPoint.v;
                const verticalLines = mesh.meshlines.filter(line =>
                    line.direction === 'vertical' &&
                    line.start <= v + epsilon &&
                    line.end >= v - epsilon &&
                    Math.abs(line.constant - startPoint.u) > epsilon
                );
                
                verticalLines.forEach(line => {
                    points.push({ u: line.constant, v, direction: 'horizontal' });
                });
            } else {
                // Extending vertically - find horizontal meshlines
                const u = startPoint.u;
                const horizontalLines = mesh.meshlines.filter(line =>
                    line.direction === 'horizontal' &&
                    line.start <= u + epsilon &&
                    line.end >= u - epsilon &&
                    Math.abs(line.constant - startPoint.v) > epsilon
                );
                
                horizontalLines.forEach(line => {
                    points.push({ u, v: line.constant, direction: 'vertical' });
                });
            }
            
            return points;
        };

        /**
         * Check if two B-splines are identical (same knot vectors)
         */
        const areBSplinesEqual = (bspline1, bspline2) => {
            const epsilon = 1e-10;
            
            if (bspline1.knotsU.length !== bspline2.knotsU.length ||
                bspline1.knotsV.length !== bspline2.knotsV.length) {
                return false;
            }
            
            for (let i = 0; i < bspline1.knotsU.length; i++) {
                if (Math.abs(bspline1.knotsU[i] - bspline2.knotsU[i]) > epsilon) {
                    return false;
                }
            }
            
            for (let i = 0; i < bspline1.knotsV.length; i++) {
                if (Math.abs(bspline1.knotsV[i] - bspline2.knotsV[i]) > epsilon) {
                    return false;
                }
            }
            
            return true;
        };

        /**
         * Remove duplicate B-splines from the list
         */
        const removeDuplicateBSplines = (bsplines) => {
            const unique = [];
            
            for (const bspline of bsplines) {
                const isDuplicate = unique.some(existing => areBSplinesEqual(existing, bspline));
                if (!isDuplicate) {
                    unique.push(bspline);
                }
            }
            
            return unique;
        };

        /**
         * Try to merge a new meshline with existing collinear meshlines
         * This handles extending T-junctions to create crossroads
         * Also merges multiple disjoint segments if the new line bridges them
         */
        const mergeOrAddMeshline = (meshlines, direction, constant, start, end, nextId) => {
            const epsilon = 1e-10;
            const nonCollinear = [];
            const collinear = [];
            
            // Separate collinear and non-collinear meshlines
            for (const line of meshlines) {
                if (line.direction === direction && 
                    Math.abs(line.constant - constant) < epsilon) {
                    collinear.push(line);
                } else {
                    nonCollinear.push(line);
                }
            }
            
            // Start with the new segment
            let mergedStart = start;
            let mergedEnd = end;
            let mergedId = nextId;
            let anyMerged = false;
            const keptCollinear = [];
            
            // Try to merge with each collinear segment
            for (const line of collinear) {
                // Check if segments are adjacent or overlapping
                if (mergedStart <= line.end + epsilon && mergedEnd >= line.start - epsilon) {
                    // Merge by taking the union
                    mergedStart = Math.min(mergedStart, line.start);
                    mergedEnd = Math.max(mergedEnd, line.end);
                    if (!anyMerged) {
                        mergedId = line.id; // Keep the first merged line's ID
                    }
                    anyMerged = true;
                } else {
                    // Keep this segment separate
                    keptCollinear.push(line);
                }
            }
            
            // Build result
            const result = [
                ...nonCollinear,
                ...keptCollinear,
                new Meshline(direction, constant, mergedStart, mergedEnd, mergedId)
            ];
            
            return { meshlines: result, wasNewLine: !anyMerged };
        };

        /**
         * Count how many times a knot value appears in a knot vector
         */
        const countKnotInVector = (knotVector, knotValue) => {
            const epsilon = 1e-10;
            let count = 0;
            for (const k of knotVector) {
                if (Math.abs(k - knotValue) < epsilon) {
                    count++;
                }
            }
            return count;
        };

        /**
         * Check if a meshline splits a B-spline
         * A meshline splits a B-spline if:
         * 1. The constant coordinate is strictly inside the B-spline's support in that direction
         * 2. The meshline spans the entire support of the B-spline in the other direction
         * 3. The knot value doesn't already exist in the B-spline's local knot vector
         *    (or exists with multiplicity less than the meshline's multiplicity)
         */
        const meshlineSplitsBSpline = (meshline, bspline, multiplicity = 1) => {
            const epsilon = 1e-10;
            const support = bspline.getSupport();
            
            if (meshline.direction === 'horizontal') {
                // Horizontal line has constant v, spans in u direction
                // Check if v is strictly inside the B-spline's v-support
                const vInside = meshline.constant > support.vMin + epsilon && 
                               meshline.constant < support.vMax - epsilon;
                // Check if line spans the entire u-support
                const uSpans = meshline.start <= support.uMin + epsilon && 
                              meshline.end >= support.uMax - epsilon;
                
                if (!vInside || !uSpans) return false;
                
                // Check if the knot already exists in the B-spline's v knot vector
                const nKnots = countKnotInVector(bspline.knotsV, meshline.constant);
                return nKnots < multiplicity;
            } else {
                // Vertical line has constant u, spans in v direction
                // Check if u is strictly inside the B-spline's u-support
                const uInside = meshline.constant > support.uMin + epsilon && 
                               meshline.constant < support.uMax - epsilon;
                // Check if line spans the entire v-support
                const vSpans = meshline.start <= support.vMin + epsilon && 
                              meshline.end >= support.vMax - epsilon;
                
                if (!uInside || !vSpans) return false;
                
                // Check if the knot already exists in the B-spline's u knot vector
                const nKnots = countKnotInVector(bspline.knotsU, meshline.constant);
                return nKnots < multiplicity;
            }
        };

        /**
         * Split a B-spline by a meshline and return the resulting B-splines
         */
        const splitBSplineByMeshline = (bspline, meshline) => {
            if (meshline.direction === 'horizontal') {
                return bspline.splitV(meshline.constant);
            } else {
                return bspline.splitU(meshline.constant);
            }
        };

        /**
         * Add a new meshline and split B-splines accordingly
         * This implements a two-step refinement process similar to the LRSplines library:
         * Step 1: Split all existing B-splines that are traversed by the new meshline
         * Step 2: Check if any newly created B-splines need to be split by existing meshlines
         * Now supports extending T-junctions by merging with existing meshlines
         */
        const addMeshline = (mesh, direction, constant, start, end) => {
            const epsilon = 1e-10;
            
            // Check if meshline already exists
            if (meshlineExists(mesh, direction, constant, start, end)) {
                return mesh;
            }

            const newMesh = { ...mesh };
            
            // Try to merge with existing meshlines (extends T-junctions)
            const mergeResult = mergeOrAddMeshline(
                mesh.meshlines, 
                direction, 
                constant, 
                start, 
                end, 
                newMesh.nextId
            );
            
            newMesh.meshlines = mergeResult.meshlines;
            if (mergeResult.wasNewLine) {
                newMesh.nextId++;
            }

            // Update global knot sets
            if (direction === 'horizontal') {
                newMesh.globalKnotsV = new Set([...mesh.globalKnotsV, constant]);
            } else {
                newMesh.globalKnotsU = new Set([...mesh.globalKnotsU, constant]);
            }

            // Find the merged meshline to use its full extent for splitting
            const mergedLine = newMesh.meshlines.find(line =>
                line.direction === direction &&
                Math.abs(line.constant - constant) < epsilon
            );
            
            // Create a meshline object for the new/merged line
            const newMeshline = {
                direction: direction,
                constant: constant,
                start: mergedLine ? mergedLine.start : start,
                end: mergedLine ? mergedLine.end : end
            };

            // STEP 1: Split all existing B-splines that are traversed by the NEW meshline
            let currentBSplines = [...mesh.bsplines];
            let newlyCreatedBSplines = [];
            
            for (const bspline of currentBSplines) {
                if (meshlineSplitsBSpline(newMeshline, bspline)) {
                    // Split the B-spline
                    const splitResult = splitBSplineByMeshline(bspline, newMeshline);
                    newlyCreatedBSplines.push(...splitResult);
                } else {
                    // Keep the B-spline as is - but it's not "newly created"
                    // We track it separately
                }
            }
            
            // Separate B-splines that weren't split
            const unsplitBSplines = currentBSplines.filter(bspline => 
                !meshlineSplitsBSpline(newMeshline, bspline)
            );

            // STEP 2: Check if any newly created B-splines need to be split by existing meshlines
            // Keep processing until no more splits occur
            let splitsOccurred = true;
            while (splitsOccurred) {
                splitsOccurred = false;
                const nextNewBSplines = [];
                
                for (const bspline of newlyCreatedBSplines) {
                    let wasSplit = false;
                    
                    // Check against all existing meshlines
                    for (const line of newMesh.meshlines) {
                        const meshlineObj = {
                            direction: line.direction,
                            constant: line.constant,
                            start: line.start,
                            end: line.end
                        };
                        
                        if (meshlineSplitsBSpline(meshlineObj, bspline)) {
                            // Split this B-spline
                            const splitResult = splitBSplineByMeshline(bspline, meshlineObj);
                            nextNewBSplines.push(...splitResult);
                            wasSplit = true;
                            splitsOccurred = true;
                            break; // Only split by one meshline at a time
                        }
                    }
                    
                    if (!wasSplit) {
                        nextNewBSplines.push(bspline);
                    }
                }
                
                newlyCreatedBSplines = nextNewBSplines;
            }
            
            // Combine unsplit and newly created B-splines
            const allBSplines = [...unsplitBSplines, ...newlyCreatedBSplines];
            
            // Remove duplicates - this can happen when splitting different B-splines
            // from left/right or top/bottom creates identical B-splines
            newMesh.bsplines = removeDuplicateBSplines(allBSplines);
            
            // Split elements that are traversed by the new meshline
            const newElements = [];
            for (const element of mesh.elements) {
                if (direction === 'horizontal') {
                    // Horizontal line splits element if it passes through its interior
                    if (constant > element.vMin + epsilon && 
                        constant < element.vMax - epsilon &&
                        mergedLine.start <= element.uMin + epsilon &&
                        mergedLine.end >= element.uMax - epsilon) {
                        // Split into two elements
                        newElements.push({
                            uMin: element.uMin,
                            uMax: element.uMax,
                            vMin: element.vMin,
                            vMax: constant
                        });
                        newElements.push({
                            uMin: element.uMin,
                            uMax: element.uMax,
                            vMin: constant,
                            vMax: element.vMax
                        });
                    } else {
                        newElements.push(element);
                    }
                } else {
                    // Vertical line splits element if it passes through its interior
                    if (constant > element.uMin + epsilon && 
                        constant < element.uMax - epsilon &&
                        mergedLine.start <= element.vMin + epsilon &&
                        mergedLine.end >= element.vMax - epsilon) {
                        // Split into two elements
                        newElements.push({
                            uMin: element.uMin,
                            uMax: constant,
                            vMin: element.vMin,
                            vMax: element.vMax
                        });
                        newElements.push({
                            uMin: constant,
                            uMax: element.uMax,
                            vMin: element.vMin,
                            vMax: element.vMax
                        });
                    } else {
                        newElements.push(element);
                    }
                }
            }
            newMesh.elements = newElements;
            
            // Sort B-splines lexicographically by knot vectors (v first, then u)
            newMesh.bsplines.sort((a, b) => {
                const epsilon = 1e-10;
                // First compare v knot vectors lexicographically
                const minLenV = Math.min(a.knotsV.length, b.knotsV.length);
                for (let i = 0; i < minLenV; i++) {
                    if (Math.abs(a.knotsV[i] - b.knotsV[i]) > epsilon) {
                        return a.knotsV[i] - b.knotsV[i];
                    }
                }
                if (a.knotsV.length !== b.knotsV.length) {
                    return a.knotsV.length - b.knotsV.length;
                }
                // Then compare u knot vectors lexicographically
                const minLenU = Math.min(a.knotsU.length, b.knotsU.length);
                for (let i = 0; i < minLenU; i++) {
                    if (Math.abs(a.knotsU[i] - b.knotsU[i]) > epsilon) {
                        return a.knotsU[i] - b.knotsU[i];
                    }
                }
                return a.knotsU.length - b.knotsU.length;
            });
            
            return newMesh;
        };

        /**
         * Main App Component
         */
        function App() {
            const [degreeU, setDegreeU] = useState(2);
            const [degreeV, setDegreeV] = useState(2);
            const [numElementsU, setNumElementsU] = useState(3);
            const [numElementsV, setNumElementsV] = useState(3);
            const [mesh, setMesh] = useState(() => createMesh(2, 2, 3, 3));
            const [refinementStart, setRefinementStart] = useState(null);
            const [selectedBSpline, setSelectedBSpline] = useState(null);
            const [showGreville, setShowGreville] = useState(true);
            const [showRefinementPoints, setShowRefinementPoints] = useState(true);
            const [showResetConfig, setShowResetConfig] = useState(false);
            const [showElementCounts, setShowElementCounts] = useState(false);
            const [peeledBSplines, setPeeledBSplines] = useState(null);
            const [showPeeledGreville, setShowPeeledGreville] = useState(false);
            const [showPeeledElementCounts, setShowPeeledElementCounts] = useState(false);
            const [nestingLevels, setNestingLevels] = useState(null);
            const [selectedNestingLevel, setSelectedNestingLevel] = useState(null);

            // Ensure numElements >= degree+1
            const minElementsU = degreeU + 1;
            const minElementsV = degreeV + 1;

            // Reset mesh
            const handleReset = () => {
                setMesh(createMesh(degreeU, degreeV, numElementsU, numElementsV));
                setRefinementStart(null);
                setSelectedBSpline(null);
            };

            // Update elements when degree changes to maintain minimum
            const handleDegreeUChange = (newDegree) => {
                setDegreeU(newDegree);
                if (numElementsU < newDegree + 1) {
                    setNumElementsU(newDegree + 1);
                }
            };

            const handleDegreeVChange = (newDegree) => {
                setDegreeV(newDegree);
                if (numElementsV < newDegree + 1) {
                    setNumElementsV(newDegree + 1);
                }
            };

            // Handle reset with current configuration values
            const handleApplyReset = () => {
                setMesh(createMesh(degreeU, degreeV, numElementsU, numElementsV));
                setRefinementStart(null);
                setSelectedBSpline(null);
                setShowResetConfig(false);
                setPeeledBSplines(null);
                setNestingLevels(null);
                setSelectedNestingLevel(null);
            };

            // Compute peeled set
            const handleComputePeeled = () => {
                const peeled = computePeeledSet(mesh.bsplines, mesh.elements);
                setPeeledBSplines(peeled);
            };

            // Compute nesting levels
            const handleComputeNestingLevels = () => {
                const levels = computeNestingLevels(mesh.bsplines);
                setNestingLevels(levels);
                setSelectedNestingLevel(null);
            };

            // Get max nesting level
            const maxNestingLevel = nestingLevels 
                ? Math.max(...nestingLevels.values())
                : 0;

            // Handle clicking on a point
            const handlePointClick = (point) => {
                if (!refinementStart) {
                    setRefinementStart(point);
                } else {
                    const direction = refinementStart.direction;
                    if (direction === 'horizontal') {
                        const minU = Math.min(refinementStart.u, point.u);
                        const maxU = Math.max(refinementStart.u, point.u);
                        const newMesh = addMeshline(mesh, 'horizontal', point.v, minU, maxU);
                        setMesh(newMesh);
                    } else {
                        const minV = Math.min(refinementStart.v, point.v);
                        const maxV = Math.max(refinementStart.v, point.v);
                        const newMesh = addMeshline(mesh, 'vertical', point.u, minV, maxV);
                        setMesh(newMesh);
                    }
                    setRefinementStart(null);
                    setSelectedBSpline(null);
                    setPeeledBSplines(null); // Clear peeled set when mesh changes
                    setNestingLevels(null);
                    setSelectedNestingLevel(null);
                }
            };

            const validStartPoints = getValidStartPoints(mesh);
            const validEndPoints = refinementStart 
                ? getValidEndPoints(mesh, refinementStart)
                : [];

            return (
                <div className="container">
                    <div className="controls">
                        <h2>LR B-Spline Refinement</h2>
                        
                        <div className="info">
                            Single B-spline start (distinct knots only). Click two points to add a refinement.
                        </div>

                        <div className="control-group">
                            <button onClick={() => setShowResetConfig(!showResetConfig)}>
                                {showResetConfig ? 'Hide' : 'Show'} Reset Configuration
                            </button>
                        </div>

                        {showResetConfig && (
                            <>
                                <div className="control-group">
                                    <label>Degree U: {degreeU}</label>
                                    <input
                                        type="range"
                                        min="1"
                                        max="5"
                                        value={degreeU}
                                        onChange={(e) => handleDegreeUChange(parseInt(e.target.value))}
                                    />
                                </div>

                                <div className="control-group">
                                    <label>Degree V: {degreeV}</label>
                                    <input
                                        type="range"
                                        min="1"
                                        max="5"
                                        value={degreeV}
                                        onChange={(e) => handleDegreeVChange(parseInt(e.target.value))}
                                    />
                                </div>

                                <div className="control-group">
                                    <label>Initial Elements U: {numElementsU} (min: {minElementsU})</label>
                                    <input
                                        type="range"
                                        min={minElementsU}
                                        max="10"
                                        value={numElementsU}
                                        onChange={(e) => setNumElementsU(parseInt(e.target.value))}
                                    />
                                </div>

                                <div className="control-group">
                                    <label>Initial Elements V: {numElementsV} (min: {minElementsV})</label>
                                    <input
                                        type="range"
                                        min={minElementsV}
                                        max="10"
                                        value={numElementsV}
                                        onChange={(e) => setNumElementsV(parseInt(e.target.value))}
                                    />
                                </div>

                                <div className="control-group">
                                    <button onClick={handleApplyReset}>Apply & Reset Mesh</button>
                                </div>
                            </>
                        )}

                        <div className="control-group">
                            {refinementStart && (
                                <button onClick={() => setRefinementStart(null)}>
                                    Clear Selection
                                </button>
                            )}
                            <button onClick={() => {
                                setShowGreville(!showGreville);
                                if (!showGreville) {
                                    setShowElementCounts(false);
                                    setShowPeeledGreville(false);
                                    setShowPeeledElementCounts(false);
                                }
                            }}>
                                {showGreville ? 'Hide' : 'Show'} Greville Points
                            </button>
                            <button onClick={() => setShowRefinementPoints(!showRefinementPoints)}>
                                {showRefinementPoints ? 'Hide' : 'Show'} Refinement Points
                            </button>
                            <button onClick={() => {
                                setShowElementCounts(!showElementCounts);
                                if (!showElementCounts) {
                                    setShowGreville(false);
                                    setShowPeeledGreville(false);
                                    setShowPeeledElementCounts(false);
                                }
                            }}>
                                {showElementCounts ? 'Hide' : 'Show'} Element Counts
                            </button>
                        </div>

                        <div className="control-group">
                            <label>Peeling:</label>
                            <button onClick={handleComputePeeled}>
                                Compute Peeled Set
                            </button>
                            {peeledBSplines && (
                                <div style={{ fontSize: '12px', color: '#666', marginBottom: '10px' }}>
                                    Peeled: {peeledBSplines.length} / {mesh.bsplines.length} B-splines
                                </div>
                            )}
                            <button 
                                onClick={() => {
                                    setShowPeeledGreville(!showPeeledGreville);
                                    if (!showPeeledGreville) {
                                        setShowGreville(false);
                                        setShowElementCounts(false);
                                        setShowPeeledElementCounts(false);
                                    }
                                }}
                                disabled={!peeledBSplines}
                            >
                                {showPeeledGreville ? 'Hide' : 'Show'} Peeled Greville
                            </button>
                            <button 
                                onClick={() => {
                                    setShowPeeledElementCounts(!showPeeledElementCounts);
                                    if (!showPeeledElementCounts) {
                                        setShowGreville(false);
                                        setShowElementCounts(false);
                                        setShowPeeledGreville(false);
                                    }
                                }}
                                disabled={!peeledBSplines}
                            >
                                {showPeeledElementCounts ? 'Hide' : 'Show'} Peeled Element Counts
                            </button>
                        </div>

                        <div className="control-group">
                            <label>Nesting Levels:</label>
                            <button onClick={handleComputeNestingLevels}>
                                Compute Nesting Levels
                            </button>
                            {nestingLevels && (
                                <>
                                    <div style={{ fontSize: '12px', color: '#666', marginBottom: '10px' }}>
                                        Max level: {maxNestingLevel}
                                    </div>
                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '5px', marginBottom: '10px' }}>
                                        <button
                                            style={{
                                                flex: '1',
                                                minWidth: '60px',
                                                background: selectedNestingLevel === null ? '#333' : '#ccc',
                                                color: selectedNestingLevel === null ? 'white' : '#333'
                                            }}
                                            onClick={() => setSelectedNestingLevel(null)}
                                        >
                                            All
                                        </button>
                                        {Array.from({ length: maxNestingLevel + 1 }, (_, i) => (
                                            <button
                                                key={i}
                                                style={{
                                                    flex: '1',
                                                    minWidth: '40px',
                                                    background: selectedNestingLevel === i ? getNestingColor(i) : '#eee',
                                                    color: selectedNestingLevel === i ? 'white' : getNestingColor(i),
                                                    border: `2px solid ${getNestingColor(i)}`
                                                }}
                                                onClick={() => setSelectedNestingLevel(selectedNestingLevel === i ? null : i)}
                                            >
                                                {i}
                                            </button>
                                        ))}
                                    </div>
                                </>
                            )}
                        </div>

                        <div className="control-group">
                            <label>Statistics:</label>
                            <div style={{ fontSize: '14px', color: '#666' }}>
                                Meshlines: {mesh.meshlines.length}<br />
                                B-splines: {mesh.bsplines.length}
                            </div>
                        </div>

                        <div className="control-group">
                            <label>B-splines (click to highlight):</label>
                            <div style={{ maxHeight: '300px', overflowY: 'auto' }}>
                                {mesh.bsplines
                                    .filter(bspline => {
                                        if (selectedNestingLevel === null || !nestingLevels) return true;
                                        return nestingLevels.get(bspline.id) === selectedNestingLevel;
                                    })
                                    .map((bspline, index) => {
                                        const level = nestingLevels ? nestingLevels.get(bspline.id) : null;
                                        const levelColor = level !== null ? getNestingColor(level) : null;
                                        return (
                                            <div
                                                key={bspline.id}
                                                className={`bspline-item ${selectedBSpline === bspline.id ? 'selected' : ''}`}
                                                style={{
                                                    borderLeftColor: levelColor || 'transparent',
                                                    borderLeftWidth: levelColor ? '4px' : '2px',
                                                    borderLeftStyle: 'solid'
                                                }}
                                                onClick={() => setSelectedBSpline(
                                                    selectedBSpline === bspline.id ? null : bspline.id
                                                )}
                                            >
                                                {level !== null && (
                                                    <span style={{ 
                                                        color: levelColor, 
                                                        fontWeight: 'bold',
                                                        marginRight: '5px'
                                                    }}>
                                                        L{level}
                                                    </span>
                                                )}
                                                u: [{bspline.knotsU.map(k => k.toFixed(2)).join(', ')}]<br />
                                                v: [{bspline.knotsV.map(k => k.toFixed(2)).join(', ')}]
                                            </div>
                                        );
                                    })}
                            </div>
                        </div>
                    </div>

                    <div className="visualization">
                        <MeshVisualization
                            mesh={mesh}
                            validStartPoints={validStartPoints}
                            validEndPoints={validEndPoints}
                            refinementStart={refinementStart}
                            selectedBSpline={selectedBSpline}
                            showGreville={showGreville}
                            showRefinementPoints={showRefinementPoints}
                            showElementCounts={showElementCounts}
                            peeledBSplines={peeledBSplines}
                            showPeeledGreville={showPeeledGreville}
                            showPeeledElementCounts={showPeeledElementCounts}
                            nestingLevels={nestingLevels}
                            selectedNestingLevel={selectedNestingLevel}
                            onPointClick={handlePointClick}
                            onGrevilleClick={setSelectedBSpline}
                        />
                    </div>
                </div>
            );
        }

        /**
         * Elements are now maintained as part of the mesh structure
         * and split during refinement, so we just return them directly
         */
        const getElements = (mesh) => {
            return mesh.elements;
        };

        /**
         * Count B-splines in each element
         */
        const countBSplinesInElements = (mesh, elements) => {
            const epsilon = 1e-10;
            return elements.map(element => {
                let count = 0;
                for (const bspline of mesh.bsplines) {
                    const support = bspline.getSupport();
                    // Check if element is contained in B-spline support
                    if (support.uMin <= element.uMin + epsilon &&
                        support.uMax >= element.uMax - epsilon &&
                        support.vMin <= element.vMin + epsilon &&
                        support.vMax >= element.vMax - epsilon) {
                        count++;
                    }
                }
                return { ...element, count };
            });
        };

        /**
         * Count B-splines from a specific set covering each element
         */
        const countBSplinesInElementsFromSet = (bsplines, elements) => {
            const epsilon = 1e-10;
            return elements.map(element => {
                let count = 0;
                for (const bspline of bsplines) {
                    const support = bspline.getSupport();
                    // Check if element is contained in B-spline support
                    if (support.uMin <= element.uMin + epsilon &&
                        support.uMax >= element.uMax - epsilon &&
                        support.vMin <= element.vMin + epsilon &&
                        support.vMax >= element.vMax - epsilon) {
                        count++;
                    }
                }
                return { ...element, count };
            });
        };

        /**
         * Get B-splines covering an element
         */
        const getBSplinesCoveringElement = (bsplines, element) => {
            const epsilon = 1e-10;
            return bsplines.filter(bspline => {
                const support = bspline.getSupport();
                return support.uMin <= element.uMin + epsilon &&
                       support.uMax >= element.uMax - epsilon &&
                       support.vMin <= element.vMin + epsilon &&
                       support.vMax >= element.vMax - epsilon;
            });
        };

        /**
         * Peeling Algorithm
         * Input: A collection of LR B-splines
         * Output: The peeled collection (B-splines that remain after removing
         *         all B-splines that at some point were the only ones covering an element)
         */
        const computePeeledSet = (bsplines, elements) => {
            // Initialize the peeled set with all B-splines
            let peeledSet = [...bsplines];
            
            // Identify all non-overloaded elements (covered by only 1 B-spline)
            // and collect B-splines covering at least one such element
            let tempSet = new Set();
            
            const findBSplinesToRemove = (currentBSplines) => {
                const toRemove = new Set();
                for (const element of elements) {
                    const covering = getBSplinesCoveringElement(currentBSplines, element);
                    if (covering.length === 1) {
                        // This element is covered by only one B-spline - mark it for removal
                        toRemove.add(covering[0]);
                    }
                }
                return toRemove;
            };
            
            // Initial identification
            tempSet = findBSplinesToRemove(peeledSet);
            
            // Iteratively remove B-splines
            while (tempSet.size > 0) {
                // Remove identified B-splines from peeled set
                peeledSet = peeledSet.filter(b => !tempSet.has(b));
                
                // Find new B-splines to remove (elements now covered by only 1)
                tempSet = findBSplinesToRemove(peeledSet);
            }
            
            return peeledSet;
        };

        /**
         * Check if support A is strictly nested inside support B
         * (A is contained in B but A != B)
         */
        const isNestedInside = (supportA, supportB) => {
            const epsilon = 1e-10;
            // A is nested inside B if B contains A and they are not equal
            const bContainsA = supportB.uMin <= supportA.uMin + epsilon &&
                              supportB.uMax >= supportA.uMax - epsilon &&
                              supportB.vMin <= supportA.vMin + epsilon &&
                              supportB.vMax >= supportA.vMax - epsilon;
            
            if (!bContainsA) return false;
            
            // Check if they are not equal (A is strictly smaller)
            const areEqual = Math.abs(supportA.uMin - supportB.uMin) < epsilon &&
                            Math.abs(supportA.uMax - supportB.uMax) < epsilon &&
                            Math.abs(supportA.vMin - supportB.vMin) < epsilon &&
                            Math.abs(supportA.vMax - supportB.vMax) < epsilon;
            
            return !areEqual;
        };

        /**
         * Nesting Level Structuring Algorithm
         * Input: A collection of B-splines
         * Output: Map from B-spline id to nesting level
         */
        const computeNestingLevels = (bsplines) => {
            const nestingLevels = new Map();
            let tempSet = [...bsplines];
            let level = 0;
            
            while (tempSet.length > 0) {
                // Find B-splines whose supports are not nested inside any other in tempSet
                const levelBSplines = [];
                
                for (const bspline of tempSet) {
                    const support = bspline.getSupport();
                    let isNested = false;
                    
                    // Check if this B-spline's support is nested inside any other
                    for (const other of tempSet) {
                        if (bspline === other) continue;
                        const otherSupport = other.getSupport();
                        
                        if (isNestedInside(support, otherSupport)) {
                            isNested = true;
                            break;
                        }
                    }
                    
                    if (!isNested) {
                        levelBSplines.push(bspline);
                    }
                }
                
                // Assign nesting level to these B-splines
                for (const bspline of levelBSplines) {
                    nestingLevels.set(bspline.id, level);
                }
                
                // Remove from temp set
                tempSet = tempSet.filter(b => !levelBSplines.includes(b));
                level++;
            }
            
            return nestingLevels;
        };

        // Colors for different nesting levels
        const NESTING_COLORS = [
            '#28a745', // Level 0 - Green
            '#007acc', // Level 1 - Blue
            '#fd7e14', // Level 2 - Orange
            '#dc3545', // Level 3 - Red
            '#9c27b0', // Level 4 - Purple
            '#00bcd4', // Level 5 - Cyan
            '#795548', // Level 6 - Brown
            '#607d8b', // Level 7 - Blue Grey
        ];

        const getNestingColor = (level) => {
            return NESTING_COLORS[level % NESTING_COLORS.length];
        };

        /**
         * Mesh Visualization Component
         */
        function MeshVisualization({ 
            mesh, 
            validStartPoints, 
            validEndPoints, 
            refinementStart,
            selectedBSpline,
            showGreville,
            showRefinementPoints,
            showElementCounts,
            peeledBSplines,
            showPeeledGreville,
            showPeeledElementCounts,
            nestingLevels,
            selectedNestingLevel,
            onPointClick,
            onGrevilleClick
        }) {
            const width = 600;
            const height = 600;
            const margin = 40;
            const scale = width - 2 * margin;

            const toSVGX = (u) => margin + u * scale;
            const toSVGY = (v) => margin + (1 - v) * scale;
            
            // Get elements and compute their B-spline counts
            const elements = getElements(mesh);
            const elementCounts = countBSplinesInElements(mesh, elements);
            
            // Compute peeled element counts if needed
            const peeledElementCounts = peeledBSplines 
                ? countBSplinesInElementsFromSet(peeledBSplines, elements)
                : null;

            // Render B-spline supports
            const renderBSplineSupports = () => {
                return mesh.bsplines
                    .filter(bspline => {
                        if (selectedNestingLevel === null || !nestingLevels) return true;
                        return nestingLevels.get(bspline.id) === selectedNestingLevel;
                    })
                    .map(bspline => {
                        const support = bspline.getSupport();
                        const x = toSVGX(support.uMin);
                        const y = toSVGY(support.vMax);
                        const w = (support.uMax - support.uMin) * scale;
                        const h = (support.vMax - support.vMin) * scale;
                        
                        const isSelected = selectedBSpline === bspline.id;
                        const level = nestingLevels ? nestingLevels.get(bspline.id) : null;
                        const levelColor = level !== null ? getNestingColor(level) : null;
                        
                        return (
                            <rect
                                key={bspline.id}
                                x={x}
                                y={y}
                                width={w}
                                height={h}
                                fill={isSelected ? (levelColor || "#007acc") : "#e0e0e0"}
                                fillOpacity={isSelected ? "0.3" : "0.15"}
                                stroke={isSelected ? (levelColor || "#007acc") : "#999"}
                                strokeWidth={isSelected ? "2" : "1"}
                                strokeDasharray={isSelected ? "none" : "3,3"}
                            />
                        );
                    });
            };

            // Render meshlines
            const renderMeshlines = () => {
                return mesh.meshlines.map(line => {
                    if (line.direction === 'horizontal') {
                        const y = toSVGY(line.constant);
                        const x1 = toSVGX(line.start);
                        const x2 = toSVGX(line.end);
                        return (
                            <line
                                key={line.id}
                                x1={x1}
                                y1={y}
                                x2={x2}
                                y2={y}
                                stroke="#333"
                                strokeWidth="2"
                            />
                        );
                    } else {
                        const x = toSVGX(line.constant);
                        const y1 = toSVGY(line.start);
                        const y2 = toSVGY(line.end);
                        return (
                            <line
                                key={line.id}
                                x1={x}
                                y1={y1}
                                x2={x}
                                y2={y2}
                                stroke="#333"
                                strokeWidth="2"
                            />
                        );
                    }
                });
            };

            // Render refinement points
            const renderRefinementPoints = () => {
                if (!showRefinementPoints) return null;
                const points = refinementStart ? validEndPoints : validStartPoints;
                const allPoints = points.map((point, idx) => {
                    const isStart = refinementStart && 
                        Math.abs(point.u - refinementStart.u) < 1e-10 && 
                        Math.abs(point.v - refinementStart.v) < 1e-10;
                    
                    return (
                        <circle
                            key={idx}
                            cx={toSVGX(point.u)}
                            cy={toSVGY(point.v)}
                            r="6"
                            fill={isStart ? "#dc3545" : "#007acc"}
                            stroke="white"
                            strokeWidth="2"
                            cursor="pointer"
                            onClick={() => onPointClick(point)}
                        />
                    );
                });

                if (refinementStart) {
                    allPoints.push(
                        <circle
                            key="start-overlay"
                            cx={toSVGX(refinementStart.u)}
                            cy={toSVGY(refinementStart.v)}
                            r="6"
                            fill="#dc3545"
                            stroke="white"
                            strokeWidth="2"
                            cursor="pointer"
                            onClick={() => onPointClick(refinementStart)}
                        />
                    );
                }

                return allPoints;
            };

            // Render preview line
            const renderPreviewLine = () => {
                if (!refinementStart) return null;

                const { u, v, direction } = refinementStart;
                
                if (direction === 'horizontal') {
                    return (
                        <line
                            x1={toSVGX(0)}
                            y1={toSVGY(v)}
                            x2={toSVGX(1)}
                            y2={toSVGY(v)}
                            stroke="#007acc"
                            strokeWidth="1"
                            strokeDasharray="5,5"
                            opacity="0.5"
                        />
                    );
                } else {
                    return (
                        <line
                            x1={toSVGX(u)}
                            y1={toSVGY(0)}
                            x2={toSVGX(u)}
                            y2={toSVGY(1)}
                            stroke="#007acc"
                            strokeWidth="1"
                            strokeDasharray="5,5"
                            opacity="0.5"
                        />
                    );
                }
            };

            // Render Greville points
            const renderGrevillePoints = () => {
                if (!showGreville) return null;
                
                return mesh.bsplines
                    .filter(bspline => {
                        if (selectedNestingLevel === null || !nestingLevels) return true;
                        return nestingLevels.get(bspline.id) === selectedNestingLevel;
                    })
                    .map(bspline => {
                        const greville = bspline.getGrevillePoint();
                        const isSelected = selectedBSpline === bspline.id;
                        const level = nestingLevels ? nestingLevels.get(bspline.id) : null;
                        const levelColor = level !== null ? getNestingColor(level) : "#28a745";
                        
                        return (
                            <circle
                                key={`greville-${bspline.id}`}
                                cx={toSVGX(greville.u)}
                                cy={toSVGY(greville.v)}
                                r="5"
                                fill={isSelected ? "#ff6b6b" : levelColor}
                                stroke="white"
                                strokeWidth="2"
                                cursor="pointer"
                                onClick={() => onGrevilleClick(bspline.id)}
                            />
                        );
                    });
            };

            // Render element counts
            const renderElementCounts = () => {
                if (!showElementCounts) return null;
                
                return elementCounts.map((element, idx) => {
                    const centerU = (element.uMin + element.uMax) / 2;
                    const centerV = (element.vMin + element.vMax) / 2;
                    
                    return (
                        <text
                            key={`count-${idx}`}
                            x={toSVGX(centerU)}
                            y={toSVGY(centerV)}
                            textAnchor="middle"
                            dominantBaseline="middle"
                            fontSize="16"
                            fontWeight="bold"
                            fill="#333"
                            style={{ pointerEvents: 'none', userSelect: 'none' }}
                        >
                            {element.count}
                        </text>
                    );
                });
            };

            // Render peeled Greville points
            const renderPeeledGrevillePoints = () => {
                if (!showPeeledGreville || !peeledBSplines) return null;
                
                return peeledBSplines.map(bspline => {
                    const greville = bspline.getGrevillePoint();
                    const isSelected = selectedBSpline === bspline.id;
                    
                    return (
                        <circle
                            key={`peeled-greville-${bspline.id}`}
                            cx={toSVGX(greville.u)}
                            cy={toSVGY(greville.v)}
                            r="5"
                            fill={isSelected ? "#ff6b6b" : "#9c27b0"}
                            stroke="white"
                            strokeWidth="2"
                            cursor="pointer"
                            onClick={() => onGrevilleClick(bspline.id)}
                        />
                    );
                });
            };

            // Render peeled element counts
            const renderPeeledElementCounts = () => {
                if (!showPeeledElementCounts || !peeledElementCounts) return null;
                
                return peeledElementCounts.map((element, idx) => {
                    const centerU = (element.uMin + element.uMax) / 2;
                    const centerV = (element.vMin + element.vMax) / 2;
                    
                    return (
                        <text
                            key={`peeled-count-${idx}`}
                            x={toSVGX(centerU)}
                            y={toSVGY(centerV)}
                            textAnchor="middle"
                            dominantBaseline="middle"
                            fontSize="16"
                            fontWeight="bold"
                            fill="#9c27b0"
                            style={{ pointerEvents: 'none', userSelect: 'none' }}
                        >
                            {element.count}
                        </text>
                    );
                });
            };

            return (
                <svg width={width} height={height}>
                    {/* Background */}
                    <rect 
                        x={margin} 
                        y={margin} 
                        width={scale} 
                        height={scale} 
                        fill="none" 
                        stroke="#ccc" 
                        strokeWidth="1" 
                    />

                    {/* B-spline supports (render first, underneath meshlines) */}
                    {renderBSplineSupports()}

                    {/* Meshlines */}
                    {renderMeshlines()}

                    {/* Preview line */}
                    {renderPreviewLine()}

                    {/* Refinement points (render first) */}
                    {renderRefinementPoints()}

                    {/* Greville points (render on top when visible) */}
                    {renderGrevillePoints()}

                    {/* Element counts */}
                    {renderElementCounts()}

                    {/* Peeled Greville points */}
                    {renderPeeledGrevillePoints()}

                    {/* Peeled element counts */}
                    {renderPeeledElementCounts()}

                    {/* Axis labels */}
                    <text x={width/2} y={height - 10} textAnchor="middle" fontSize="14" fill="#666">u</text>
                    <text x={10} y={height/2} textAnchor="middle" fontSize="14" fill="#666" transform={`rotate(-90, 10, ${height/2})`}>v</text>
                </svg>
            );
        }

        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
