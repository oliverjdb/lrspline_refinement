<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LR B-Spline Refinement Visualization (3D)</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .controls {
            width: 320px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .visualization {
            flex: 1;
            position: relative;
        }
        #threejs-canvas {
            width: 100%;
            height: 100%;
        }
        h2 {
            margin-top: 0;
            color: #333;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-weight: 500;
            font-size: 13px;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        button {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            background: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover {
            background: #005a9e;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
            color: #1976d2;
            margin-bottom: 15px;
        }
        .stats {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #333;
            margin-bottom: 15px;
        }
        .bspline-item {
            padding: 4px 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            font-family: monospace;
        }
        .bspline-item:hover {
            background: #f0f0f0;
        }
        .bspline-item.selected {
            border-color: #007acc;
            background: #e3f2fd;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .checkbox-group input {
            width: auto;
            margin: 0;
        }
        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }
        .controls.hidden {
            display: none;
        }
        .menu-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: background 0.2s;
        }
        .menu-toggle:hover {
            background: #005a9e;
        }
        .menu-toggle.menu-visible {
            display: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Make THREE available globally for the Babel script
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;
        
        // Signal that Three.js is loaded
        window.dispatchEvent(new Event('three-loaded'));
    </script>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect, useRef } = React;

        let nextBSplineId = 0;
        const generateBSplineId = () => nextBSplineId++;
        const resetBSplineIdCounter = () => { nextBSplineId = 0; };

        /**
         * LRBSpline3D class - represents a single LR B-spline in 3D
         * Knot vectors have distinct values (no multiplicity)
         */
        class LRBSpline3D {
            constructor(knotsU, knotsV, knotsW, id = null) {
                this.id = id !== null ? id : generateBSplineId();
                this.knotsU = [...knotsU];
                this.knotsV = [...knotsV];
                this.knotsW = [...knotsW];
            }

            /**
             * Get the support of this B-spline (3D bounding box)
             */
            getSupport() {
                return {
                    uMin: this.knotsU[0],
                    uMax: this.knotsU[this.knotsU.length - 1],
                    vMin: this.knotsV[0],
                    vMax: this.knotsV[this.knotsV.length - 1],
                    wMin: this.knotsW[0],
                    wMax: this.knotsW[this.knotsW.length - 1]
                };
            }

            /**
             * Calculate the Greville point (average of interior knots) in 3D
             * For degree p with p+2 knots, Greville point is average of middle p knots
             */
            getGrevillePoint() {
                const degreeU = this.knotsU.length - 2;
                const degreeV = this.knotsV.length - 2;
                const degreeW = this.knotsW.length - 2;
                
                // Average of interior knots (exclude first and last)
                let u = 0;
                for (let i = 1; i <= degreeU; i++) {
                    u += this.knotsU[i];
                }
                u /= degreeU;
                
                let v = 0;
                for (let i = 1; i <= degreeV; i++) {
                    v += this.knotsV[i];
                }
                v /= degreeV;
                
                let w = 0;
                for (let i = 1; i <= degreeW; i++) {
                    w += this.knotsW[i];
                }
                w /= degreeW;
                
                return { u, v, w };
            }

            /**
             * Split B-spline by inserting a new knot in U direction
             * Returns two new B-splines
             */
            splitU(newKnot) {
                const epsilon = 1e-10;
                const degreeU = this.knotsU.length - 2;
                
                const newKnotsU = [...this.knotsU];
                let insertIdx = newKnotsU.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsU.length;
                newKnotsU.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline3D(
                    newKnotsU.slice(0, degreeU + 2),
                    this.knotsV,
                    this.knotsW
                );
                const bspline2 = new LRBSpline3D(
                    newKnotsU.slice(1, degreeU + 3),
                    this.knotsV,
                    this.knotsW
                );
                
                return [bspline1, bspline2];
            }

            /**
             * Split B-spline by inserting a new knot in V direction
             * Returns two new B-splines
             */
            splitV(newKnot) {
                const epsilon = 1e-10;
                const degreeV = this.knotsV.length - 2;
                
                const newKnotsV = [...this.knotsV];
                let insertIdx = newKnotsV.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsV.length;
                newKnotsV.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline3D(
                    this.knotsU,
                    newKnotsV.slice(0, degreeV + 2),
                    this.knotsW
                );
                const bspline2 = new LRBSpline3D(
                    this.knotsU,
                    newKnotsV.slice(1, degreeV + 3),
                    this.knotsW
                );
                
                return [bspline1, bspline2];
            }

            /**
             * Split B-spline by inserting a new knot in W direction
             * Returns two new B-splines
             */
            splitW(newKnot) {
                const epsilon = 1e-10;
                const degreeW = this.knotsW.length - 2;
                
                const newKnotsW = [...this.knotsW];
                let insertIdx = newKnotsW.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsW.length;
                newKnotsW.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline3D(
                    this.knotsU,
                    this.knotsV,
                    newKnotsW.slice(0, degreeW + 2)
                );
                const bspline2 = new LRBSpline3D(
                    this.knotsU,
                    this.knotsV,
                    newKnotsW.slice(1, degreeW + 3)
                );
                
                return [bspline1, bspline2];
            }
        }

        /**
         * Meshface storage - element-level coverage for each plane
         * 
         * A "meshface" is an element-sized piece of a refinement region.
         * When a user specifies a refinement (a potentially large rectangular region),
         * it gets decomposed into element-sized meshfaces for storage.
         * 
         * Structure: Map<planeKey, Set<meshfaceKey>>
         * - planeKey: "normalAxis_constant" (e.g., "u_0.5000000000")
         * - meshfaceKey: "span1Start_span1End_span2Start_span2End" (element-sized rectangle)
         * 
         * For a U-perpendicular plane: span1 is V, span2 is W
         * For a V-perpendicular plane: span1 is U, span2 is W
         * For a W-perpendicular plane: span1 is U, span2 is V
         * 
         * This unified structure:
         * - Is the single source of truth (no redundancy)
         * - Enables efficient coverage checks (Set lookups)
         * - Naturally supports multiplicity tracking (future: Map<meshfaceKey, multiplicity>)
         */

        /**
         * Parse a plane key into its components
         */
        const parsePlaneKey = (planeKey) => {
            const [normalAxis, constantStr] = planeKey.split('_');
            return { normalAxis, constant: parseFloat(constantStr) };
        };

        /**
         * Create a plane key from components
         */
        const makePlaneKey = (normalAxis, constant) => {
            return `${normalAxis}_${constant.toFixed(10)}`;
        };

        /**
         * Parse a meshface key into its components
         */
        const parseMeshfaceKey = (meshfaceKey) => {
            const parts = meshfaceKey.split('_').map(parseFloat);
            return {
                span1Start: parts[0],
                span1End: parts[1],
                span2Start: parts[2],
                span2End: parts[3]
            };
        };

        /**
         * Create a meshface key from components
         */
        const makeMeshfaceKey = (span1Start, span1End, span2Start, span2End) => {
            return `${span1Start}_${span1End}_${span2Start}_${span2End}`;
        };

        /**
         * Get all unique constants for a given axis from the meshfaces
         */
        const getPlaneConstants = (meshfaces, normalAxis) => {
            const constants = new Set();
            for (const [planeKey, mfSet] of meshfaces) {
                const parsed = parsePlaneKey(planeKey);
                if (parsed.normalAxis === normalAxis && mfSet.size > 0) {
                    constants.add(parsed.constant);
                }
            }
            return Array.from(constants).sort((a, b) => a - b);
        };

        /**
         * Check if a meshface at a given position on a plane is covered
         */
        const isMeshfaceCovered = (meshfaces, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = meshfaces.get(planeKey);
            if (!mfSet) return false;
            
            // Check if the exact meshface exists
            const meshfaceKey = makeMeshfaceKey(span1Start, span1End, span2Start, span2End);
            return mfSet.has(meshfaceKey);
        };

        /**
         * Check if a point (span1, span2) on a plane at (normalAxis, constant) is covered by any meshface
         */
        const isPointOnPlaneCovered = (meshfaces, normalAxis, constant, span1, span2) => {
            const epsilon = 1e-10;
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = meshfaces.get(planeKey);
            if (!mfSet) return false;
            
            for (const meshfaceKey of mfSet) {
                const mf = parseMeshfaceKey(meshfaceKey);
                if (span1 >= mf.span1Start - epsilon && span1 <= mf.span1End + epsilon &&
                    span2 >= mf.span2Start - epsilon && span2 <= mf.span2End + epsilon) {
                    return true;
                }
            }
            return false;
        };

        /**
         * Get the bounding box of all meshfaces on a plane
         * Returns { span1Min, span1Max, span2Min, span2Max } or null if no meshfaces
         */
        const getPlaneBounds = (meshfaces, normalAxis, constant) => {
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = meshfaces.get(planeKey);
            if (!mfSet || mfSet.size === 0) return null;
            
            let span1Min = Infinity, span1Max = -Infinity;
            let span2Min = Infinity, span2Max = -Infinity;
            
            for (const meshfaceKey of mfSet) {
                const mf = parseMeshfaceKey(meshfaceKey);
                span1Min = Math.min(span1Min, mf.span1Start);
                span1Max = Math.max(span1Max, mf.span1End);
                span2Min = Math.min(span2Min, mf.span2Start);
                span2Max = Math.max(span2Max, mf.span2End);
            }
            
            return { span1Min, span1Max, span2Min, span2Max };
        };

        /**
         * Check if a region on a plane overlaps with any existing meshfaces
         */
        const regionOverlapsMeshfaces = (meshfaces, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = meshfaces.get(planeKey);
            if (!mfSet) return false;
            
            for (const meshfaceKey of mfSet) {
                const mf = parseMeshfaceKey(meshfaceKey);
                // Check for overlap (not just touching)
                if (mf.span1Start < span1End - epsilon && mf.span1End > span1Start + epsilon &&
                    mf.span2Start < span2End - epsilon && mf.span2End > span2Start + epsilon) {
                    return true;
                }
            }
            return false;
        };

        /**
         * Get the extent of meshfaces at a constant position, limited to a range in one span direction
         * This is used to find the coverage of a plane at a specific span1 or span2 value
         */
        const getMeshfaceExtentAtPosition = (meshfaces, normalAxis, constant, fixedSpan, isSpan1Fixed) => {
            const epsilon = 1e-10;
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = meshfaces.get(planeKey);
            if (!mfSet) return null;
            
            let minVal = Infinity, maxVal = -Infinity;
            let found = false;
            
            for (const meshfaceKey of mfSet) {
                const mf = parseMeshfaceKey(meshfaceKey);
                if (isSpan1Fixed) {
                    // Check if fixedSpan is within this meshface's span1 range
                    if (fixedSpan >= mf.span1Start - epsilon && fixedSpan <= mf.span1End + epsilon) {
                        minVal = Math.min(minVal, mf.span2Start);
                        maxVal = Math.max(maxVal, mf.span2End);
                        found = true;
                    }
                } else {
                    // Check if fixedSpan is within this meshface's span2 range
                    if (fixedSpan >= mf.span2Start - epsilon && fixedSpan <= mf.span2End + epsilon) {
                        minVal = Math.min(minVal, mf.span1Start);
                        maxVal = Math.max(maxVal, mf.span1End);
                        found = true;
                    }
                }
            }
            
            return found ? { min: minVal, max: maxVal } : null;
        };

        /**
         * Check if a meshface region at the given position fully covers the specified region
         * (This replaces the old meshfaceExists function)
         */
        const meshfaceCoversRegion = (meshfaces, normalAxis, constant, span1Start, span1End, span2Start, span2End, globalKnots1, globalKnots2) => {
            const epsilon = 1e-10;
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = meshfaces.get(planeKey);
            if (!mfSet) return false;
            
            // Find all element meshfaces within the region and check if they're all covered
            const knots1 = Array.from(globalKnots1).sort((a, b) => a - b);
            const knots2 = Array.from(globalKnots2).sort((a, b) => a - b);
            
            for (let i = 0; i < knots1.length - 1; i++) {
                const mfStart1 = knots1[i];
                const mfEnd1 = knots1[i + 1];
                if (mfEnd1 <= span1Start + epsilon || mfStart1 >= span1End - epsilon) continue;
                
                for (let j = 0; j < knots2.length - 1; j++) {
                    const mfStart2 = knots2[j];
                    const mfEnd2 = knots2[j + 1];
                    if (mfEnd2 <= span2Start + epsilon || mfStart2 >= span2End - epsilon) continue;
                    
                    const meshfaceKey = makeMeshfaceKey(mfStart1, mfEnd1, mfStart2, mfEnd2);
                    if (!mfSet.has(meshfaceKey)) {
                        return false;
                    }
                }
            }
            
            return true;
        };

        /**
         * Iterate over all meshfaces and yield face-like objects
         * Each yielded object has: normalAxis, constant, span1Start, span1End, span2Start, span2End
         * and convenience accessors uStart/uEnd, vStart/vEnd, wStart/wEnd based on normalAxis
         */
        const iterateMeshfaces = function*(meshfaces) {
            for (const [planeKeyStr, meshfaceSet] of meshfaces) {
                const { normalAxis, constant } = parsePlaneKey(planeKeyStr);
                
                for (const meshfaceKeyStr of meshfaceSet) {
                    const mf = parseMeshfaceKey(meshfaceKeyStr);
                    
                    // Create a face-like object for compatibility
                    const face = {
                        normalAxis,
                        constant,
                        span1Start: mf.span1Start,
                        span1End: mf.span1End,
                        span2Start: mf.span2Start,
                        span2End: mf.span2End
                    };
                    
                    // Add convenience accessors based on normalAxis
                    if (normalAxis === 'u') {
                        face.vStart = mf.span1Start;
                        face.vEnd = mf.span1End;
                        face.wStart = mf.span2Start;
                        face.wEnd = mf.span2End;
                    } else if (normalAxis === 'v') {
                        face.uStart = mf.span1Start;
                        face.uEnd = mf.span1End;
                        face.wStart = mf.span2Start;
                        face.wEnd = mf.span2End;
                    } else { // w
                        face.uStart = mf.span1Start;
                        face.uEnd = mf.span1End;
                        face.vStart = mf.span2Start;
                        face.vEnd = mf.span2End;
                    }
                    
                    yield face;
                }
            }
        };

        /**
         * Count how many times a knot value appears in a knot vector
         */
        const countKnotInVector = (knotVector, knotValue) => {
            const epsilon = 1e-10;
            let count = 0;
            for (const k of knotVector) {
                if (Math.abs(k - knotValue) < epsilon) {
                    count++;
                }
            }
            return count;
        };

        /**
         * Check if a meshface splits a B-spline
         * A meshface splits a B-spline if:
         * 1. The constant coordinate is strictly inside the B-spline's support in that direction
         * 2. The meshface spans the entire support of the B-spline in the other two directions
         * 3. The knot value doesn't already exist in the B-spline's local knot vector
         */
        const meshfaceSplitsBSpline = (meshface, bspline, multiplicity = 1) => {
            const epsilon = 1e-10;
            const support = bspline.getSupport();
            
            if (meshface.normalAxis === 'u') {
                // Face perpendicular to U: check if u is strictly inside
                const uInside = meshface.constant > support.uMin + epsilon && 
                               meshface.constant < support.uMax - epsilon;
                // Check if face spans the entire v and w support
                const vSpans = meshface.vStart <= support.vMin + epsilon && 
                              meshface.vEnd >= support.vMax - epsilon;
                const wSpans = meshface.wStart <= support.wMin + epsilon && 
                              meshface.wEnd >= support.wMax - epsilon;
                
                if (!uInside || !vSpans || !wSpans) return false;
                
                // Check if the knot already exists
                const nKnots = countKnotInVector(bspline.knotsU, meshface.constant);
                return nKnots < multiplicity;
                
            } else if (meshface.normalAxis === 'v') {
                // Face perpendicular to V: check if v is strictly inside
                const vInside = meshface.constant > support.vMin + epsilon && 
                               meshface.constant < support.vMax - epsilon;
                // Check if face spans the entire u and w support
                const uSpans = meshface.uStart <= support.uMin + epsilon && 
                              meshface.uEnd >= support.uMax - epsilon;
                const wSpans = meshface.wStart <= support.wMin + epsilon && 
                              meshface.wEnd >= support.wMax - epsilon;
                
                if (!vInside || !uSpans || !wSpans) return false;
                
                // Check if the knot already exists
                const nKnots = countKnotInVector(bspline.knotsV, meshface.constant);
                return nKnots < multiplicity;
                
            } else { // normalAxis === 'w'
                // Face perpendicular to W: check if w is strictly inside
                const wInside = meshface.constant > support.wMin + epsilon && 
                               meshface.constant < support.wMax - epsilon;
                // Check if face spans the entire u and v support
                const uSpans = meshface.uStart <= support.uMin + epsilon && 
                              meshface.uEnd >= support.uMax - epsilon;
                const vSpans = meshface.vStart <= support.vMin + epsilon && 
                              meshface.vEnd >= support.vMax - epsilon;
                
                if (!wInside || !uSpans || !vSpans) return false;
                
                // Check if the knot already exists
                const nKnots = countKnotInVector(bspline.knotsW, meshface.constant);
                return nKnots < multiplicity;
            }
        };

        /**
         * Split a B-spline by a plane and return the resulting B-splines
         */
        const splitBSplineByPlane = (bspline, normalAxis, constant) => {
            if (normalAxis === 'u') {
                return bspline.splitU(constant);
            } else if (normalAxis === 'v') {
                return bspline.splitV(constant);
            } else {
                return bspline.splitW(constant);
            }
        };

        /**
         * Check if two 3D B-splines are identical (same knot vectors)
         */
        const areBSplines3DEqual = (bspline1, bspline2) => {
            const epsilon = 1e-10;
            
            if (bspline1.knotsU.length !== bspline2.knotsU.length ||
                bspline1.knotsV.length !== bspline2.knotsV.length ||
                bspline1.knotsW.length !== bspline2.knotsW.length) {
                return false;
            }
            
            for (let i = 0; i < bspline1.knotsU.length; i++) {
                if (Math.abs(bspline1.knotsU[i] - bspline2.knotsU[i]) > epsilon) {
                    return false;
                }
            }
            
            for (let i = 0; i < bspline1.knotsV.length; i++) {
                if (Math.abs(bspline1.knotsV[i] - bspline2.knotsV[i]) > epsilon) {
                    return false;
                }
            }
            
            for (let i = 0; i < bspline1.knotsW.length; i++) {
                if (Math.abs(bspline1.knotsW[i] - bspline2.knotsW[i]) > epsilon) {
                    return false;
                }
            }
            
            return true;
        };

        /**
         * Remove duplicate 3D B-splines from the list
         */
        const removeDuplicateBSplines3D = (bsplines) => {
            const unique = [];
            
            for (const bspline of bsplines) {
                const isDuplicate = unique.some(existing => areBSplines3DEqual(existing, bspline));
                if (!isDuplicate) {
                    unique.push(bspline);
                }
            }
            
            return unique;
        };

        /**
         * Element3D class - represents a 3D element (hexahedral box) in the LR mesh
         * Elements are axis-aligned boxes defined by their min/max coordinates
         */
        class Element3D {
            constructor(uMin, uMax, vMin, vMax, wMin, wMax) {
                this.uMin = uMin;
                this.uMax = uMax;
                this.vMin = vMin;
                this.vMax = vMax;
                this.wMin = wMin;
                this.wMax = wMax;
            }

            /**
             * Get the center point of this element
             */
            getCenter() {
                return {
                    u: (this.uMin + this.uMax) / 2,
                    v: (this.vMin + this.vMax) / 2,
                    w: (this.wMin + this.wMax) / 2
                };
            }

            /**
             * Get the dimensions of this element
             */
            getDimensions() {
                return {
                    du: this.uMax - this.uMin,
                    dv: this.vMax - this.vMin,
                    dw: this.wMax - this.wMin
                };
            }

            /**
             * Get the volume of this element
             */
            getVolume() {
                const dims = this.getDimensions();
                return dims.du * dims.dv * dims.dw;
            }

            /**
             * Check if a point is inside this element
             */
            containsPoint(u, v, w) {
                const epsilon = 1e-10;
                return u >= this.uMin - epsilon && u <= this.uMax + epsilon &&
                       v >= this.vMin - epsilon && v <= this.vMax + epsilon &&
                       w >= this.wMin - epsilon && w <= this.wMax + epsilon;
            }

            /**
             * Check if this element is contained within a B-spline's support
             */
            isContainedInSupport(support) {
                const epsilon = 1e-10;
                return support.uMin <= this.uMin + epsilon &&
                       support.uMax >= this.uMax - epsilon &&
                       support.vMin <= this.vMin + epsilon &&
                       support.vMax >= this.vMax - epsilon &&
                       support.wMin <= this.wMin + epsilon &&
                       support.wMax >= this.wMax - epsilon;
            }

            /**
             * Check if a plane passes through the interior of this element
             * (can split the element)
             */
            isSplitByPlane(normalAxis, constant, span1Start, span1End, span2Start, span2End) {
                const epsilon = 1e-10;
                
                if (normalAxis === 'u') {
                    // Plane perpendicular to U: check if constant is strictly inside u range
                    // and plane spans the element's v and w extent
                    const uInside = constant > this.uMin + epsilon && 
                                   constant < this.uMax - epsilon;
                    const vSpans = span1Start <= this.vMin + epsilon && 
                                  span1End >= this.vMax - epsilon;
                    const wSpans = span2Start <= this.wMin + epsilon && 
                                  span2End >= this.wMax - epsilon;
                    return uInside && vSpans && wSpans;
                    
                } else if (normalAxis === 'v') {
                    // Plane perpendicular to V
                    const vInside = constant > this.vMin + epsilon && 
                                   constant < this.vMax - epsilon;
                    const uSpans = span1Start <= this.uMin + epsilon && 
                                  span1End >= this.uMax - epsilon;
                    const wSpans = span2Start <= this.wMin + epsilon && 
                                  span2End >= this.wMax - epsilon;
                    return vInside && uSpans && wSpans;
                    
                } else { // normalAxis === 'w'
                    // Plane perpendicular to W
                    const wInside = constant > this.wMin + epsilon && 
                                   constant < this.wMax - epsilon;
                    const uSpans = span1Start <= this.uMin + epsilon && 
                                  span1End >= this.uMax - epsilon;
                    const vSpans = span2Start <= this.vMin + epsilon && 
                                  span2End >= this.vMax - epsilon;
                    return wInside && uSpans && vSpans;
                }
            }

            /**
             * Split this element by a plane
             * Returns two new elements if split occurs, otherwise returns [this]
             */
            splitByPlane(normalAxis, constant, span1Start, span1End, span2Start, span2End) {
                if (!this.isSplitByPlane(normalAxis, constant, span1Start, span1End, span2Start, span2End)) {
                    return [this];
                }
                
                if (normalAxis === 'u') {
                    return [
                        new Element3D(this.uMin, constant, this.vMin, this.vMax, this.wMin, this.wMax),
                        new Element3D(constant, this.uMax, this.vMin, this.vMax, this.wMin, this.wMax)
                    ];
                } else if (normalAxis === 'v') {
                    return [
                        new Element3D(this.uMin, this.uMax, this.vMin, constant, this.wMin, this.wMax),
                        new Element3D(this.uMin, this.uMax, constant, this.vMax, this.wMin, this.wMax)
                    ];
                } else {
                    return [
                        new Element3D(this.uMin, this.uMax, this.vMin, this.vMax, this.wMin, constant),
                        new Element3D(this.uMin, this.uMax, this.vMin, this.vMax, constant, this.wMax)
                    ];
                }
            }

            /**
             * Create a plain object representation (for compatibility)
             */
            toObject() {
                return {
                    uMin: this.uMin,
                    uMax: this.uMax,
                    vMin: this.vMin,
                    vMax: this.vMax,
                    wMin: this.wMin,
                    wMax: this.wMax
                };
            }
        }

        /**
         * Get T-junction edges from meshfaces in 3D
         * A T-junction occurs when a meshface edge doesn't extend to the domain boundary
         * Returns points along these edges that can be used to extend the meshface
         */
        const getTJunctionPoints3D = (mesh, normalAxis) => {
            const epsilon = 1e-10;
            const points = [];
            
            const knotsU = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
            const knotsV = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            const knotsW = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            
            const pointExists = (u, v, w) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon && 
                    Math.abs(p.w - w) < epsilon
                );
            };
            
            // Find meshfaces with the specified normal axis that have T-junction edges
            for (const face of iterateMeshfaces(mesh.meshfaces)) {
                if (face.normalAxis !== normalAxis) continue;
                
                if (normalAxis === 'u') {
                    const u = face.constant;
                    // Check V edges (at vStart and vEnd)
                    // If vStart > 0, this is a T-junction edge - can extend downward in V
                    if (face.vStart > epsilon) {
                        // Points along this edge at W knot positions
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(u, face.vStart, w)) {
                                    points.push({ u, v: face.vStart, w, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                    // If vEnd < 1, this is a T-junction edge - can extend upward in V
                    if (face.vEnd < 1 - epsilon) {
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(u, face.vEnd, w)) {
                                    points.push({ u, v: face.vEnd, w, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                    // Check W edges (at wStart and wEnd)
                    if (face.wStart > epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(u, v, face.wStart)) {
                                    points.push({ u, v, w: face.wStart, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.wEnd < 1 - epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(u, v, face.wEnd)) {
                                    points.push({ u, v, w: face.wEnd, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                } else if (normalAxis === 'v') {
                    const v = face.constant;
                    // Check U edges
                    if (face.uStart > epsilon) {
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(face.uStart, v, w)) {
                                    points.push({ u: face.uStart, v, w, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.uEnd < 1 - epsilon) {
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(face.uEnd, v, w)) {
                                    points.push({ u: face.uEnd, v, w, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                    // Check W edges
                    if (face.wStart > epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, v, face.wStart)) {
                                    points.push({ u, v, w: face.wStart, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.wEnd < 1 - epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, v, face.wEnd)) {
                                    points.push({ u, v, w: face.wEnd, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                } else { // normalAxis === 'w'
                    const w = face.constant;
                    // Check U edges
                    if (face.uStart > epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(face.uStart, v, w)) {
                                    points.push({ u: face.uStart, v, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.uEnd < 1 - epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(face.uEnd, v, w)) {
                                    points.push({ u: face.uEnd, v, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                    // Check V edges
                    if (face.vStart > epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, face.vStart, w)) {
                                    points.push({ u, v: face.vStart, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.vEnd < 1 - epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, face.vEnd, w)) {
                                    points.push({ u, v: face.vEnd, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Get valid start points for refinement in 3D
         * A valid start point is on an existing meshface where a new perpendicular meshface can begin
         * 
         * For a refinement with normal axis 'axis', valid start points are on meshfaces 
         * perpendicular to one of the OTHER two axes, at positions where the 'axis' coordinate
         * lies between existing knots.
         * 
         * Also includes T-junction points for extending existing local refinements.
         * 
         * Returns array of { u, v, w, normalAxis } where normalAxis is the axis for the new meshface
         */
        const getValidStartPoints3D = (mesh, normalAxis) => {
            const epsilon = 1e-10;
            const points = [];
            
            const pointExists = (u, v, w) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon && 
                    Math.abs(p.w - w) < epsilon
                );
            };
            
            // Get global knots for each axis
            const knotsU = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
            const knotsV = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            const knotsW = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            
            // For normal axis 'u', we need points where u is at a midpoint between knots
            // and the point lies on existing meshfaces perpendicular to V or W
            if (normalAxis === 'u') {
                // Find midpoints in U direction
                const midpointsU = [];
                for (let i = 0; i < knotsU.length - 1; i++) {
                    midpointsU.push((knotsU[i] + knotsU[i + 1]) / 2);
                }
                
                // Look for points on V-perpendicular meshfaces
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'v') {
                        const v = face.constant;
                        // For each midpoint in U and knot in W
                        for (const u of midpointsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                for (const w of knotsW) {
                                    if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'u' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on W-perpendicular meshfaces
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'w') {
                        const w = face.constant;
                        // For each midpoint in U and knot in V
                        for (const u of midpointsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                for (const v of knotsV) {
                                    if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'u' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (normalAxis === 'v') {
                // Find midpoints in V direction
                const midpointsV = [];
                for (let i = 0; i < knotsV.length - 1; i++) {
                    midpointsV.push((knotsV[i] + knotsV[i + 1]) / 2);
                }
                
                // Look for points on U-perpendicular meshfaces
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'u') {
                        const u = face.constant;
                        for (const v of midpointsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                for (const w of knotsW) {
                                    if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'v' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on W-perpendicular meshfaces
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'w') {
                        const w = face.constant;
                        for (const v of midpointsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                for (const u of knotsU) {
                                    if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'v' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else { // normalAxis === 'w'
                // Find midpoints in W direction
                const midpointsW = [];
                for (let i = 0; i < knotsW.length - 1; i++) {
                    midpointsW.push((knotsW[i] + knotsW[i + 1]) / 2);
                }
                
                // Look for points on U-perpendicular meshfaces
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'u') {
                        const u = face.constant;
                        for (const w of midpointsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                for (const v of knotsV) {
                                    if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'w' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on V-perpendicular meshfaces
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'v') {
                        const v = face.constant;
                        for (const w of midpointsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                for (const u of knotsU) {
                                    if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'w' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Add T-junction extension points from existing meshfaces of the selected normalAxis
            // These points are on the edges of meshfaces that don't reach the boundary
            const tJunctionPoints = getTJunctionPoints3D(mesh, normalAxis);
            for (const tjPt of tJunctionPoints) {
                if (!pointExists(tjPt.u, tjPt.v, tjPt.w)) {
                    points.push(tjPt);
                }
            }
            
            // Helper: check if a plane at this constant is "incomplete" (non-tensor-product)
            // i.e., the union of meshfaces on this plane doesn't cover the full domain [0,1]x[0,1]
            const isPlaneIncomplete = (constant) => {
                const planeKey = makePlaneKey(normalAxis, constant);
                const mfSet = mesh.meshfaces.get(planeKey);
                if (!mfSet || mfSet.size === 0) return false;
                
                // Check if the meshfaces fully cover [0,1]x[0,1]
                // A simple check: if any meshface doesn't reach the boundary, plane is incomplete
                for (const meshfaceKeyStr of mfSet) {
                    const mf = parseMeshfaceKey(meshfaceKeyStr);
                    if (mf.span1Start > epsilon || mf.span1End < 1 - epsilon ||
                        mf.span2Start > epsilon || mf.span2End < 1 - epsilon) {
                        return true; // At least one meshface is incomplete
                    }
                }
                return false; // All meshfaces span the full domain
            };
            
            // Only add plane corner points on INCOMPLETE planes (non-tensor-product)
            // This allows extending local refinements but doesn't clutter tensor-product planes
            const existingConstants = new Set();
            for (const face of iterateMeshfaces(mesh.meshfaces)) {
                if (face.normalAxis === normalAxis) {
                    existingConstants.add(face.constant);
                }
            }
            
            for (const constant of existingConstants) {
                // Skip if this plane is already complete (tensor-product)
                if (!isPlaneIncomplete(constant)) continue;
                
                // Find all valid corners on this plane (intersections of perpendicular faces)
                if (normalAxis === 'u') {
                    // For U-normal plane at u=constant, find V-W intersections
                    for (const vFace of iterateMeshfaces(mesh.meshfaces)) {
                        if (vFace.normalAxis === 'v' && 
                            constant >= vFace.uStart - epsilon && constant <= vFace.uEnd + epsilon) {
                            const v = vFace.constant;
                            for (const wFace of iterateMeshfaces(mesh.meshfaces)) {
                                if (wFace.normalAxis === 'w' &&
                                    constant >= wFace.uStart - epsilon && constant <= wFace.uEnd + epsilon &&
                                    v >= wFace.vStart - epsilon && v <= wFace.vEnd + epsilon) {
                                    const w = wFace.constant;
                                    // Check this point is within the V-face's W span
                                    if (w >= vFace.wStart - epsilon && w <= vFace.wEnd + epsilon) {
                                        if (!pointExists(constant, v, w)) {
                                            points.push({ u: constant, v, w, normalAxis: 'u', isPlanePoint: true });
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (normalAxis === 'v') {
                    // For V-normal plane at v=constant, find U-W intersections
                    for (const uFace of iterateMeshfaces(mesh.meshfaces)) {
                        if (uFace.normalAxis === 'u' &&
                            constant >= uFace.vStart - epsilon && constant <= uFace.vEnd + epsilon) {
                            const u = uFace.constant;
                            for (const wFace of iterateMeshfaces(mesh.meshfaces)) {
                                if (wFace.normalAxis === 'w' &&
                                    constant >= wFace.vStart - epsilon && constant <= wFace.vEnd + epsilon &&
                                    u >= wFace.uStart - epsilon && u <= wFace.uEnd + epsilon) {
                                    const w = wFace.constant;
                                    // Check this point is within the U-face's W span
                                    if (w >= uFace.wStart - epsilon && w <= uFace.wEnd + epsilon) {
                                        if (!pointExists(u, constant, w)) {
                                            points.push({ u, v: constant, w, normalAxis: 'v', isPlanePoint: true });
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else { // normalAxis === 'w'
                    // For W-normal plane at w=constant, find U-V intersections
                    for (const uFace of iterateMeshfaces(mesh.meshfaces)) {
                        if (uFace.normalAxis === 'u' &&
                            constant >= uFace.wStart - epsilon && constant <= uFace.wEnd + epsilon) {
                            const u = uFace.constant;
                            for (const vFace of iterateMeshfaces(mesh.meshfaces)) {
                                if (vFace.normalAxis === 'v' &&
                                    constant >= vFace.wStart - epsilon && constant <= vFace.wEnd + epsilon &&
                                    u >= vFace.uStart - epsilon && u <= vFace.uEnd + epsilon) {
                                    const v = vFace.constant;
                                    // Check this point is within the U-face's V span
                                    if (v >= uFace.vStart - epsilon && v <= uFace.vEnd + epsilon) {
                                        if (!pointExists(u, v, constant)) {
                                            points.push({ u, v, w: constant, normalAxis: 'w', isPlanePoint: true });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Get valid end points given a start point for 3D refinement
         * The end point completes the rectangular region of the meshface
         * It must be on an existing meshface that intersects the plane defined by the start point
         */
        const getValidEndPoints3D = (mesh, startPoint) => {
            const epsilon = 1e-10;
            const points = [];
            const { u: startU, v: startV, w: startW, normalAxis } = startPoint;
            
            const pointExists = (u, v, w) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon && 
                    Math.abs(p.w - w) < epsilon
                );
            };
            
            const knotsU = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
            const knotsV = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            const knotsW = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            
            if (normalAxis === 'u') {
                // The meshface is at u = startU, we need to find valid corners in the V-W plane
                // End point must be different from start in both v and w
                
                // Look for points on V-perpendicular meshfaces at u = startU
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'v' && 
                        startU >= face.uStart - epsilon && startU <= face.uEnd + epsilon) {
                        const v = face.constant;
                        if (Math.abs(v - startV) > epsilon) {
                            for (const w of knotsW) {
                                if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon &&
                                    Math.abs(w - startW) > epsilon) {
                                    if (!pointExists(startU, v, w)) {
                                        points.push({ u: startU, v, w, normalAxis: 'u' });
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on W-perpendicular meshfaces at u = startU
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'w' && 
                        startU >= face.uStart - epsilon && startU <= face.uEnd + epsilon) {
                        const w = face.constant;
                        if (Math.abs(w - startW) > epsilon) {
                            for (const v of knotsV) {
                                if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon &&
                                    Math.abs(v - startV) > epsilon) {
                                    if (!pointExists(startU, v, w)) {
                                        points.push({ u: startU, v, w, normalAxis: 'u' });
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (normalAxis === 'v') {
                // The meshface is at v = startV, we need to find valid corners in the U-W plane
                
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'u' && 
                        startV >= face.vStart - epsilon && startV <= face.vEnd + epsilon) {
                        const u = face.constant;
                        if (Math.abs(u - startU) > epsilon) {
                            for (const w of knotsW) {
                                if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon &&
                                    Math.abs(w - startW) > epsilon) {
                                    if (!pointExists(u, startV, w)) {
                                        points.push({ u, v: startV, w, normalAxis: 'v' });
                                    }
                                }
                            }
                        }
                    }
                }
                
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'w' && 
                        startV >= face.vStart - epsilon && startV <= face.vEnd + epsilon) {
                        const w = face.constant;
                        if (Math.abs(w - startW) > epsilon) {
                            for (const u of knotsU) {
                                if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon &&
                                    Math.abs(u - startU) > epsilon) {
                                    if (!pointExists(u, startV, w)) {
                                        points.push({ u, v: startV, w, normalAxis: 'v' });
                                    }
                                }
                            }
                        }
                    }
                }
            } else { // normalAxis === 'w'
                // The meshface is at w = startW, we need to find valid corners in the U-V plane
                
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'u' && 
                        startW >= face.wStart - epsilon && startW <= face.wEnd + epsilon) {
                        const u = face.constant;
                        if (Math.abs(u - startU) > epsilon) {
                            for (const v of knotsV) {
                                if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon &&
                                    Math.abs(v - startV) > epsilon) {
                                    if (!pointExists(u, v, startW)) {
                                        points.push({ u, v, w: startW, normalAxis: 'w' });
                                    }
                                }
                            }
                        }
                    }
                }
                
                for (const face of iterateMeshfaces(mesh.meshfaces)) {
                    if (face.normalAxis === 'v' && 
                        startW >= face.wStart - epsilon && startW <= face.wEnd + epsilon) {
                        const v = face.constant;
                        if (Math.abs(v - startV) > epsilon) {
                            for (const u of knotsU) {
                                if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon &&
                                    Math.abs(u - startU) > epsilon) {
                                    if (!pointExists(u, v, startW)) {
                                        points.push({ u, v, w: startW, normalAxis: 'w' });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Count B-splines covering each 3D element
         */
        const countBSplinesInElements3D = (bsplines, elements) => {
            return elements.map(element => {
                let count = 0;
                for (const bspline of bsplines) {
                    const support = bspline.getSupport();
                    if (element.isContainedInSupport(support)) {
                        count++;
                    }
                }
                return { element, count };
            });
        };

        /**
         * Get B-splines covering a 3D element
         */
        const getBSplinesCoveringElement3D = (bsplines, element) => {
            return bsplines.filter(bspline => {
                const support = bspline.getSupport();
                return element.isContainedInSupport(support);
            });
        };

        /**
         * Create initial 3D mesh
         */
        const createMesh3D = (degreeU, degreeV, degreeW, numElementsU, numElementsV, numElementsW) => {
            resetBSplineIdCounter();
            
            const knotsU = [], knotsV = [], knotsW = [];
            for (let i = 0; i <= numElementsU; i++) knotsU.push(i / numElementsU);
            for (let i = 0; i <= numElementsV; i++) knotsV.push(i / numElementsV);
            for (let i = 0; i <= numElementsW; i++) knotsW.push(i / numElementsW);
            
            // meshfaces stores element-level mesh coverage for each plane
            // Key: "normalAxis_constant" (e.g., "u_0.5")
            // Value: Set of cell keys "span1Start_span1End_span2Start_span2End"
            const meshfaces = new Map();
            
            // Create initial tensor-product meshfaces (full coverage on all planes)
            // U-perpendicular faces at each U knot
            for (const u of knotsU) {
                const key = makePlaneKey('u', u);
                const mfSet = new Set();
                // Full coverage: all V-W element meshfaces
                for (let j = 0; j < numElementsV; j++) {
                    for (let k = 0; k < numElementsW; k++) {
                        mfSet.add(makeMeshfaceKey(knotsV[j], knotsV[j+1], knotsW[k], knotsW[k+1]));
                    }
                }
                meshfaces.set(key, mfSet);
            }
            
            // V-perpendicular faces at each V knot
            for (const v of knotsV) {
                const key = makePlaneKey('v', v);
                const mfSet = new Set();
                // Full coverage: all U-W element meshfaces
                for (let i = 0; i < numElementsU; i++) {
                    for (let k = 0; k < numElementsW; k++) {
                        mfSet.add(makeMeshfaceKey(knotsU[i], knotsU[i+1], knotsW[k], knotsW[k+1]));
                    }
                }
                meshfaces.set(key, mfSet);
            }
            
            // W-perpendicular faces at each W knot
            for (const w of knotsW) {
                const key = makePlaneKey('w', w);
                const mfSet = new Set();
                // Full coverage: all U-V element meshfaces
                for (let i = 0; i < numElementsU; i++) {
                    for (let j = 0; j < numElementsV; j++) {
                        mfSet.add(makeMeshfaceKey(knotsU[i], knotsU[i+1], knotsV[j], knotsV[j+1]));
                    }
                }
                meshfaces.set(key, mfSet);
            }
            
            // Create B-splines
            const bsplines = [];
            const numBSplinesU = knotsU.length - degreeU - 1;
            const numBSplinesV = knotsV.length - degreeV - 1;
            const numBSplinesW = knotsW.length - degreeW - 1;
            
            for (let i = 0; i < numBSplinesU; i++) {
                for (let j = 0; j < numBSplinesV; j++) {
                    for (let k = 0; k < numBSplinesW; k++) {
                        bsplines.push(new LRBSpline3D(
                            knotsU.slice(i, i + degreeU + 2),
                            knotsV.slice(j, j + degreeV + 2),
                            knotsW.slice(k, k + degreeW + 2)
                        ));
                    }
                }
            }
            
            // Create elements
            const elements = [];
            for (let i = 0; i < numElementsU; i++) {
                for (let j = 0; j < numElementsV; j++) {
                    for (let k = 0; k < numElementsW; k++) {
                        elements.push(new Element3D(
                            knotsU[i], knotsU[i + 1],
                            knotsV[j], knotsV[j + 1],
                            knotsW[k], knotsW[k + 1]
                        ));
                    }
                }
            }
            
            return {
                meshfaces, bsplines, elements,
                degreeU, degreeV, degreeW,
                globalKnotsU: new Set(knotsU),
                globalKnotsV: new Set(knotsV),
                globalKnotsW: new Set(knotsW)
            };
        };

        /**
         * Get all element meshfaces that a refinement region covers
         * Returns array of { span1Start, span1End, span2Start, span2End }
         */
        const getRefinementMeshfaces = (mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            const result = [];
            
            // Get the appropriate knot arrays for the two span directions
            let knots1, knots2;
            if (normalAxis === 'u') {
                knots1 = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
                knots2 = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            } else if (normalAxis === 'v') {
                knots1 = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
                knots2 = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            } else {
                knots1 = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
                knots2 = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            }
            
            // Find all element meshfaces that overlap with the refinement region
            for (let i = 0; i < knots1.length - 1; i++) {
                const mfStart1 = knots1[i];
                const mfEnd1 = knots1[i + 1];
                
                // Check if this meshface overlaps with span1
                if (mfEnd1 <= span1Start + epsilon || mfStart1 >= span1End - epsilon) continue;
                
                for (let j = 0; j < knots2.length - 1; j++) {
                    const mfStart2 = knots2[j];
                    const mfEnd2 = knots2[j + 1];
                    
                    // Check if this meshface overlaps with span2
                    if (mfEnd2 <= span2Start + epsilon || mfStart2 >= span2End - epsilon) continue;
                    
                    result.push({
                        span1Start: mfStart1, span1End: mfEnd1,
                        span2Start: mfStart2, span2End: mfEnd2
                    });
                }
            }
            
            return result;
        };

        /**
         * Check if meshfaces on a plane fully cover a B-spline's support
         */
        const meshfacesCoverBSpline = (mesh, normalAxis, constant, bspline) => {
            const epsilon = 1e-10;
            const support = bspline.getSupport();
            
            // Check if the constant is strictly inside the B-spline's support
            if (normalAxis === 'u') {
                if (constant <= support.uMin + epsilon || constant >= support.uMax - epsilon) return false;
            } else if (normalAxis === 'v') {
                if (constant <= support.vMin + epsilon || constant >= support.vMax - epsilon) return false;
            } else {
                if (constant <= support.wMin + epsilon || constant >= support.wMax - epsilon) return false;
            }
            
            // Check if the knot already exists in the B-spline
            if (normalAxis === 'u' && countKnotInVector(bspline.knotsU, constant) > 0) return false;
            if (normalAxis === 'v' && countKnotInVector(bspline.knotsV, constant) > 0) return false;
            if (normalAxis === 'w' && countKnotInVector(bspline.knotsW, constant) > 0) return false;
            
            // Get the meshfaces for this plane
            const planeKey = makePlaneKey(normalAxis, constant);
            const mfSet = mesh.meshfaces.get(planeKey);
            if (!mfSet || mfSet.size === 0) return false;
            
            // Determine the span ranges we need to cover based on B-spline support
            let span1Min, span1Max, span2Min, span2Max;
            if (normalAxis === 'u') {
                span1Min = support.vMin; span1Max = support.vMax;
                span2Min = support.wMin; span2Max = support.wMax;
            } else if (normalAxis === 'v') {
                span1Min = support.uMin; span1Max = support.uMax;
                span2Min = support.wMin; span2Max = support.wMax;
            } else {
                span1Min = support.uMin; span1Max = support.uMax;
                span2Min = support.vMin; span2Max = support.vMax;
            }
            
            // Find all element meshfaces that need to be covered
            const requiredMeshfaces = getRefinementMeshfaces(mesh, normalAxis, constant, span1Min, span1Max, span2Min, span2Max);
            
            // Check if all required meshfaces are present
            for (const mf of requiredMeshfaces) {
                const meshfaceKey = makeMeshfaceKey(mf.span1Start, mf.span1End, mf.span2Start, mf.span2End);
                if (!mfSet.has(meshfaceKey)) {
                    return false;
                }
            }
            
            return true;
        };

        /**
         * Add a refinement and perform B-spline splitting
         * This implements a two-step refinement process similar to the LRSplines library:
         * Step 1: Split all existing B-splines that are traversed by the new refinement
         * Step 2: Check if any newly created B-splines need to be split by existing meshfaces
         * Uses element-level meshface storage for clean coverage checks
         */
        const addRefinement = (mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            const newMesh = { ...mesh };
            
            // Clone the meshfaces map
            newMesh.meshfaces = new Map();
            for (const [key, mfSet] of mesh.meshfaces) {
                newMesh.meshfaces.set(key, new Set(mfSet));
            }
            
            // Update global knots first (needed for meshface calculation)
            if (normalAxis === 'u') newMesh.globalKnotsU = new Set([...mesh.globalKnotsU, constant]);
            else if (normalAxis === 'v') newMesh.globalKnotsV = new Set([...mesh.globalKnotsV, constant]);
            else newMesh.globalKnotsW = new Set([...mesh.globalKnotsW, constant]);
            
            // Get the meshfaces covered by this new refinement
            const newMeshfaces = getRefinementMeshfaces(newMesh, normalAxis, constant, span1Start, span1End, span2Start, span2End);
            
            // Add meshfaces to the storage (only new ones)
            const planeKey = makePlaneKey(normalAxis, constant);
            if (!newMesh.meshfaces.has(planeKey)) {
                newMesh.meshfaces.set(planeKey, new Set());
            }
            const planeMeshfaces = newMesh.meshfaces.get(planeKey);
            
            let addedAnyMeshfaces = false;
            for (const mf of newMeshfaces) {
                const meshfaceKey = makeMeshfaceKey(mf.span1Start, mf.span1End, mf.span2Start, mf.span2End);
                if (!planeMeshfaces.has(meshfaceKey)) {
                    planeMeshfaces.add(meshfaceKey);
                    addedAnyMeshfaces = true;
                }
            }
            
            // If no new meshfaces were added, nothing to do
            if (!addedAnyMeshfaces) {
                return mesh;  // Return original mesh unchanged
            }
            
            // STEP 1: Split all existing B-splines that have full meshface coverage
            let currentBSplines = [...mesh.bsplines];
            let newlyCreated = [];
            let splitBSplineIds = new Set();
            
            for (const bspline of currentBSplines) {
                if (meshfacesCoverBSpline(newMesh, normalAxis, constant, bspline)) {
                    newlyCreated.push(...splitBSplineByPlane(bspline, normalAxis, constant));
                    splitBSplineIds.add(bspline.id);
                }
            }
            
            const unsplit = currentBSplines.filter(b => !splitBSplineIds.has(b.id));
            
            // STEP 2: Check if any newly created B-splines need to be split by existing meshfaces
            let splitsOccurred = true;
            while (splitsOccurred) {
                splitsOccurred = false;
                const nextNew = [];
                for (const bspline of newlyCreated) {
                    let wasSplit = false;
                    
                    // Check all planes in meshfaces
                    for (const [planeKeyStr, mfSet] of newMesh.meshfaces) {
                        const parsed = parsePlaneKey(planeKeyStr);
                        
                        if (meshfacesCoverBSpline(newMesh, parsed.normalAxis, parsed.constant, bspline)) {
                            nextNew.push(...splitBSplineByPlane(bspline, parsed.normalAxis, parsed.constant));
                            wasSplit = true;
                            splitsOccurred = true;
                            break;
                        }
                    }
                    
                    if (!wasSplit) nextNew.push(bspline);
                }
                newlyCreated = nextNew;
            }
            
            newMesh.bsplines = removeDuplicateBSplines3D([...unsplit, ...newlyCreated]);
            
            // Split elements by the new meshface
            const nextElements = [];
            for (const element of mesh.elements) {
                nextElements.push(...element.splitByPlane(normalAxis, constant, span1Start, span1End, span2Start, span2End));
            }
            newMesh.elements = nextElements;
            
            return newMesh;
        };

        /**
         * Three.js Visualization Component
         */
        function ThreeVisualization({ 
            mesh, 
            selectedBSpline, 
            showMeshfaces, 
            showGreville, 
            showElements, 
            showBSplineSupports,
            refinementPoints,
            refinementStart,
            onPointClick,
            onGrevilleClick,
            showRefinementPoints,
            inspectionPlane,
            onInspectionClick,
            showInspectionPoints
        }) {
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const controlsRef = useRef(null);
            const clickablePointsRef = useRef([]);
            const grevillePointsRef = useRef([]);
            const inspectionPointsRef = useRef([]);

            useEffect(() => {
                if (!containerRef.current) return;

                // Setup scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                sceneRef.current = scene;

                // Setup camera
                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.set(2, 2, 2);
                cameraRef.current = camera;

                // Setup renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Setup controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.target.set(0.5, 0.5, 0.5);
                controls.update();
                controlsRef.current = controls;

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // Axes helper removed - bounding box is sufficient

                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                // Handle resize
                const handleResize = () => {
                    if (!containerRef.current) return;
                    const w = containerRef.current.clientWidth;
                    const h = containerRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            // Handle click events for refinement points and Greville points
            useEffect(() => {
                if (!rendererRef.current || !cameraRef.current || !sceneRef.current) return;
                
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                const handleClick = (event) => {
                    const rect = rendererRef.current.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, cameraRef.current);
                    
                    // First check refinement points
                    if (showRefinementPoints && clickablePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(clickablePointsRef.current);
                        if (intersects.length > 0) {
                            const clickedPoint = intersects[0].object.userData.pointData;
                            if (clickedPoint && onPointClick) {
                                onPointClick(clickedPoint);
                                return;
                            }
                        }
                    }
                    
                    // Check inspection points
                    if (inspectionPointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(inspectionPointsRef.current);
                        if (intersects.length > 0) {
                            const planeData = intersects[0].object.userData.planeData;
                            if (planeData && onInspectionClick) {
                                onInspectionClick(planeData);
                                return;
                            }
                        }
                    }
                    
                    // Then check Greville points
                    if (showGreville && grevillePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(grevillePointsRef.current);
                        if (intersects.length > 0) {
                            const bsplineId = intersects[0].object.userData.bsplineId;
                            if (bsplineId !== undefined && onGrevilleClick) {
                                onGrevilleClick(bsplineId);
                                return;
                            }
                        }
                    }
                };
                
                const handleMouseMove = (event) => {
                    const rect = rendererRef.current.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, cameraRef.current);
                    
                    // Check refinement points first
                    if (showRefinementPoints && clickablePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(clickablePointsRef.current);
                        if (intersects.length > 0) {
                            rendererRef.current.domElement.style.cursor = 'pointer';
                            return;
                        }
                    }
                    
                    // Check inspection points
                    if (inspectionPointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(inspectionPointsRef.current);
                        if (intersects.length > 0) {
                            rendererRef.current.domElement.style.cursor = 'pointer';
                            return;
                        }
                    }
                    
                    // Then check Greville points
                    if (showGreville && grevillePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(grevillePointsRef.current);
                        if (intersects.length > 0) {
                            rendererRef.current.domElement.style.cursor = 'pointer';
                            return;
                        }
                    }
                    
                    rendererRef.current.domElement.style.cursor = 'grab';
                };
                
                rendererRef.current.domElement.addEventListener('click', handleClick);
                rendererRef.current.domElement.addEventListener('mousemove', handleMouseMove);
                
                return () => {
                    if (rendererRef.current) {
                        rendererRef.current.domElement.removeEventListener('click', handleClick);
                        rendererRef.current.domElement.removeEventListener('mousemove', handleMouseMove);
                    }
                };
            }, [showRefinementPoints, showGreville, onPointClick, onGrevilleClick, onInspectionClick]);

            // Update visualization when mesh changes
            useEffect(() => {
                if (!sceneRef.current) return;
                const scene = sceneRef.current;

                // Remove old mesh objects
                const toRemove = [];
                scene.traverse(obj => {
                    if (obj.userData.isMeshObject) toRemove.push(obj);
                });
                toRemove.forEach(obj => scene.remove(obj));
                clickablePointsRef.current = [];
                grevillePointsRef.current = [];
                inspectionPointsRef.current = [];

                // Draw bounding box
                const boxGeo = new THREE.BoxGeometry(1, 1, 1);
                const boxEdges = new THREE.EdgesGeometry(boxGeo);
                const boxLines = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0x333333 }));
                boxLines.position.set(0.5, 0.5, 0.5);
                boxLines.userData.isMeshObject = true;
                scene.add(boxLines);

                // Draw meshfaces
                if (showMeshfaces) {
                    for (const face of iterateMeshfaces(mesh.meshfaces)) {
                        let geometry, position;
                        
                        if (face.normalAxis === 'u') {
                            const width = face.span1End - face.span1Start;
                            const height = face.span2End - face.span2Start;
                            geometry = new THREE.PlaneGeometry(width, height);
                            position = new THREE.Vector3(face.constant, (face.span1Start + face.span1End) / 2, (face.span2Start + face.span2End) / 2);
                            geometry.rotateY(Math.PI / 2);
                        } else if (face.normalAxis === 'v') {
                            const width = face.span1End - face.span1Start;
                            const height = face.span2End - face.span2Start;
                            geometry = new THREE.PlaneGeometry(width, height);
                            position = new THREE.Vector3((face.span1Start + face.span1End) / 2, face.constant, (face.span2Start + face.span2End) / 2);
                            geometry.rotateX(-Math.PI / 2);
                        } else {
                            const width = face.span1End - face.span1Start;
                            const height = face.span2End - face.span2Start;
                            geometry = new THREE.PlaneGeometry(width, height);
                            position = new THREE.Vector3((face.span1Start + face.span1End) / 2, (face.span2Start + face.span2End) / 2, face.constant);
                        }
                        
                        const material = new THREE.MeshBasicMaterial({ 
                            color: 0x007acc, 
                            transparent: true, 
                            opacity: inspectionPlane ? 0.03 : 0.1, 
                            side: THREE.DoubleSide 
                        });
                        const plane = new THREE.Mesh(geometry, material);
                        plane.position.copy(position);
                        plane.userData.isMeshObject = true;
                        scene.add(plane);

                        // Add edges
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x007acc,
                            transparent: inspectionPlane ? true : false,
                            opacity: inspectionPlane ? 0.1 : 1.0
                        }));
                        line.position.copy(position);
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    }
                }

                // Draw elements (with transparency during refinement)
                if (showElements) {
                    mesh.elements.forEach(el => {
                        const sizeU = el.uMax - el.uMin;
                        const sizeV = el.vMax - el.vMin;
                        const sizeW = el.wMax - el.wMin;
                        const geo = new THREE.BoxGeometry(sizeU, sizeV, sizeW);
                        const edges = new THREE.EdgesGeometry(geo);
                        const lineMat = new THREE.LineBasicMaterial({ 
                            color: 0x999999,
                            transparent: (refinementStart || inspectionPlane) ? true : false,
                            opacity: (refinementStart || inspectionPlane) ? 0.1 : 1.0
                        });
                        const line = new THREE.LineSegments(edges, lineMat);
                        line.position.set(
                            (el.uMin + el.uMax) / 2,
                            (el.vMin + el.vMax) / 2,
                            (el.wMin + el.wMax) / 2
                        );
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    });
                }

                // Draw B-spline supports (only selected, or all if showBSplineSupports is on)
                // During refinement, make transparent to avoid occluding plane and points
                mesh.bsplines.forEach(bspline => {
                    const support = bspline.getSupport();
                    const isSelected = selectedBSpline === bspline.id;
                    
                    // Only draw if selected, or if showBSplineSupports is on
                    if (!isSelected && !showBSplineSupports) return;
                    
                    const sizeU = support.uMax - support.uMin;
                    const sizeV = support.vMax - support.vMin;
                    const sizeW = support.wMax - support.wMin;
                    
                    if (isSelected) {
                        const geo = new THREE.BoxGeometry(sizeU * 0.998, sizeV * 0.998, sizeW * 0.998);
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: 0xff6600, 
                            transparent: true, 
                            opacity: (refinementStart || inspectionPlane) ? 0.05 : 0.3  // Very faint during refinement or inspection
                        });
                        const box = new THREE.Mesh(geo, mat);
                        box.position.set(
                            (support.uMin + support.uMax) / 2,
                            (support.vMin + support.vMax) / 2,
                            (support.wMin + support.wMax) / 2
                        );
                        box.userData.isMeshObject = true;
                        scene.add(box);

                        const edges = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0xff6600, 
                            linewidth: 2,
                            transparent: true,
                            opacity: (refinementStart || inspectionPlane) ? 0.1 : 1.0  // Faint during refinement or inspection
                        }));
                        line.position.copy(box.position);
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    } else if (showBSplineSupports) {
                        // Unselected supports - very faint outline only
                        const geo = new THREE.BoxGeometry(sizeU * 0.998, sizeV * 0.998, sizeW * 0.998);
                        const edges = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x999999, 
                            transparent: true,
                            opacity: inspectionPlane ? 0.05 : 0.2  // Even fainter during inspection
                        }));
                        line.position.set(
                            (support.uMin + support.uMax) / 2,
                            (support.vMin + support.vMax) / 2,
                            (support.wMin + support.wMax) / 2
                        );
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    }
                });

                // Draw Greville points (clickable to select B-spline)
                if (showGreville) {
                    const sphereGeo = new THREE.SphereGeometry(0.015, 16, 16);
                    mesh.bsplines.forEach(bspline => {
                        const greville = bspline.getGrevillePoint();
                        const isSelected = selectedBSpline === bspline.id;
                        const mat = new THREE.MeshBasicMaterial({ color: isSelected ? 0xff0000 : 0x28a745 });
                        const sphere = new THREE.Mesh(sphereGeo, mat);
                        sphere.position.set(greville.u, greville.v, greville.w);
                        sphere.userData.isMeshObject = true;
                        sphere.userData.isGrevillePoint = true;
                        sphere.userData.bsplineId = bspline.id;
                        scene.add(sphere);
                        grevillePointsRef.current.push(sphere);
                    });
                }

                // Helper function to draw a plane visualization with optional meshface shading
                // Used by both refinement preview and inspection mode
                const drawPlaneVisualization = (normalAxis, constant, options = {}) => {
                    const {
                        planeColor = 0x007acc,
                        planeOpacity = 0.15,
                        gridColor = 0x0056a3,
                        showMeshfaceCoverage = false,
                        coverageColor = 0x4CAF50,
                        coverageOpacity = 0.5,
                        showDashedOutline = false,
                        baseRenderOrder = 100
                    } = options;
                    
                    const epsilon = 1e-10;
                    
                    // Create plane geometry based on normal axis
                    let planeGeo;
                    if (normalAxis === 'u') {
                        planeGeo = new THREE.PlaneGeometry(1, 1);
                        planeGeo.rotateY(Math.PI / 2);
                        planeGeo.translate(constant, 0.5, 0.5);
                    } else if (normalAxis === 'v') {
                        planeGeo = new THREE.PlaneGeometry(1, 1);
                        planeGeo.rotateX(-Math.PI / 2);
                        planeGeo.translate(0.5, constant, 0.5);
                    } else {
                        planeGeo = new THREE.PlaneGeometry(1, 1);
                        planeGeo.translate(0.5, 0.5, constant);
                    }
                    
                    // Draw semi-transparent plane background
                    const planeMat = new THREE.MeshBasicMaterial({
                        color: planeColor,
                        transparent: true,
                        opacity: planeOpacity,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const planeMesh = new THREE.Mesh(planeGeo, planeMat);
                    planeMesh.userData.isMeshObject = true;
                    planeMesh.renderOrder = baseRenderOrder;
                    scene.add(planeMesh);
                    
                    // Optional dashed outline
                    if (showDashedOutline) {
                        const edges = new THREE.EdgesGeometry(planeGeo);
                        const lineMat = new THREE.LineDashedMaterial({ 
                            color: planeColor, 
                            dashSize: 0.05, 
                            gapSize: 0.02 
                        });
                        const line = new THREE.LineSegments(edges, lineMat);
                        line.computeLineDistances();
                        line.userData.isMeshObject = true;
                        line.renderOrder = baseRenderOrder;
                        scene.add(line);
                    }
                    
                    // Draw meshface coverage if requested
                    if (showMeshfaceCoverage) {
                        const planeKey = makePlaneKey(normalAxis, constant);
                        const mfSet = mesh.meshfaces.get(planeKey);
                        
                        if (mfSet) {
                            const faceMat = new THREE.MeshBasicMaterial({
                                color: coverageColor,
                                transparent: true,
                                opacity: coverageOpacity,
                                side: THREE.DoubleSide,
                                depthWrite: false
                            });
                            
                            for (const meshfaceKey of mfSet) {
                                const parts = meshfaceKey.split('_').map(parseFloat);
                                const span1Start = parts[0];
                                const span1End = parts[1];
                                const span2Start = parts[2];
                                const span2End = parts[3];
                                
                                const width = span1End - span1Start;
                                const height = span2End - span2Start;
                                
                                let faceGeo;
                                if (normalAxis === 'u') {
                                    faceGeo = new THREE.PlaneGeometry(height, width);
                                    faceGeo.rotateY(Math.PI / 2);
                                    faceGeo.translate(constant, span1Start + width/2, span2Start + height/2);
                                } else if (normalAxis === 'v') {
                                    faceGeo = new THREE.PlaneGeometry(width, height);
                                    faceGeo.rotateX(-Math.PI / 2);
                                    faceGeo.translate(span1Start + width/2, constant, span2Start + height/2);
                                } else {
                                    faceGeo = new THREE.PlaneGeometry(width, height);
                                    faceGeo.translate(span1Start + width/2, span2Start + height/2, constant);
                                }
                                
                                const faceMesh = new THREE.Mesh(faceGeo, faceMat);
                                faceMesh.userData.isMeshObject = true;
                                faceMesh.renderOrder = baseRenderOrder + 1;
                                scene.add(faceMesh);
                            }
                        }
                    }
                    
                    // Draw element grid lines on the plane
                    const gridLineMat = new THREE.LineBasicMaterial({ color: gridColor, linewidth: 1 });
                    const gridPoints = [];
                    
                    mesh.elements.forEach(el => {
                        if (normalAxis === 'u') {
                            if (constant >= el.uMin - epsilon && constant <= el.uMax + epsilon) {
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMax));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMax));
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMax));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMax));
                            }
                        } else if (normalAxis === 'v') {
                            if (constant >= el.vMin - epsilon && constant <= el.vMax + epsilon) {
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMax));
                            }
                        } else {
                            if (constant >= el.wMin - epsilon && constant <= el.wMax + epsilon) {
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMax, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMax, constant));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMax, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMax, constant));
                            }
                        }
                    });
                    
                    if (gridPoints.length > 0) {
                        const gridGeometry = new THREE.BufferGeometry().setFromPoints(gridPoints);
                        const gridLines = new THREE.LineSegments(gridGeometry, gridLineMat);
                        gridLines.userData.isMeshObject = true;
                        gridLines.renderOrder = baseRenderOrder + 2;
                        scene.add(gridLines);
                    }
                };

                // Draw preview plane when start point is selected (before refinement points)
                if (refinementStart) {
                    const { u, v, w, normalAxis } = refinementStart;
                    const constant = normalAxis === 'u' ? u : (normalAxis === 'v' ? v : w);
                    
                    drawPlaneVisualization(normalAxis, constant, {
                        planeColor: 0x007acc,
                        planeOpacity: 0.15,
                        gridColor: 0x0056a3,
                        showMeshfaceCoverage: true,
                        coverageColor: 0x007acc,
                        coverageOpacity: 0.3,
                        showDashedOutline: true,
                        baseRenderOrder: 1500
                    });
                }

                // Draw refinement points LAST so they're always on top (most important when active)
                if (showRefinementPoints && refinementPoints && refinementPoints.length > 0) {
                    const pointSphereGeo = new THREE.SphereGeometry(0.012, 12, 12);
                    
                    refinementPoints.forEach((point, idx) => {
                        const isStartPoint = refinementStart && 
                            Math.abs(point.u - refinementStart.u) < 1e-10 &&
                            Math.abs(point.v - refinementStart.v) < 1e-10 &&
                            Math.abs(point.w - refinementStart.w) < 1e-10;
                        
                        // Check if this point is already covered by an existing meshface
                        // Get the constant and span coordinates based on normalAxis
                        let constant, span1, span2;
                        if (point.normalAxis === 'u') {
                            constant = point.u;
                            span1 = point.v;
                            span2 = point.w;
                        } else if (point.normalAxis === 'v') {
                            constant = point.v;
                            span1 = point.u;
                            span2 = point.w;
                        } else {
                            constant = point.w;
                            span1 = point.u;
                            span2 = point.v;
                        }
                        const isCovered = isPointOnPlaneCovered(mesh.meshfaces, point.normalAxis, constant, span1, span2);
                        
                        // Simple color scheme: blue for available points, red for selected
                        const color = isStartPoint ? 0xdc3545 : 0x007acc;
                        
                        // Points NOT covered by existing meshfaces are opaque (new refinement opportunities)
                        // Points already covered are semi-transparent (part of existing mesh)
                        const baseOpacity = isCovered ? 0.25 : 0.85;
                        
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: color,
                            transparent: true,
                            opacity: isStartPoint ? 1.0 : baseOpacity,
                            depthTest: false  // Always render on top
                        });
                        const sphere = new THREE.Mesh(pointSphereGeo, mat);
                        sphere.position.set(point.u, point.v, point.w);
                        sphere.userData.isMeshObject = true;
                        sphere.userData.pointData = point;
                        sphere.userData.isClickable = true;
                        sphere.renderOrder = 1000;  // Highest priority
                        scene.add(sphere);
                        clickablePointsRef.current.push(sphere);
                    });
                    
                    // Also draw the start point if set (extra emphasis)
                    if (refinementStart) {
                        const startMat = new THREE.MeshBasicMaterial({ 
                            color: 0xdc3545,
                            depthTest: false
                        });
                        const startSphere = new THREE.Mesh(pointSphereGeo, startMat);
                        startSphere.position.set(refinementStart.u, refinementStart.v, refinementStart.w);
                        startSphere.userData.isMeshObject = true;
                        startSphere.renderOrder = 1001;  // Even higher than other refinement points
                        scene.add(startSphere);
                    }
                }

                // Draw inspection points outside the cube at all four edges/corners for each plane
                // Only show on incomplete planes (not full tensor-product coverage)
                if (showInspectionPoints) {
                    const offset = -0.04;
                    const far = 1 + 0.04;
                    const inspSphereGeo = new THREE.SphereGeometry(0.009, 12, 12);
                    const epsilon = 1e-10;
                    
                    // Helper to check if a plane has complete coverage of [0,1][0,1]
                    // Uses a coverage-based approach: builds a grid from meshface boundaries
                    // and checks that every cell in the grid is covered by at least one meshface.
                    // This is robust to meshfaces having different granularities from different refinements.
                    const isPlaneComplete = (normalAxis, constant) => {
                        const planeKey = makePlaneKey(normalAxis, constant);
                        const mfSet = mesh.meshfaces.get(planeKey);
                        if (!mfSet || mfSet.size === 0) return true; // No meshfaces = boundary plane, treat as complete
                        
                        // Round to avoid floating point precision issues
                        // (e.g., 0.333333333 vs 0.333333334 from different refinements)
                        const round = (x) => Math.round(x * 1000000) / 1000000;
                        
                        // Collect all meshfaces as rectangles (with rounded boundaries)
                        const rects = [];
                        for (const meshfaceKeyStr of mfSet) {
                            const mf = parseMeshfaceKey(meshfaceKeyStr);
                            rects.push({
                                s1: round(mf.span1Start), e1: round(mf.span1End),
                                s2: round(mf.span2Start), e2: round(mf.span2End)
                            });
                        }
                        
                        // Collect all unique boundaries (including domain boundaries 0 and 1)
                        const boundaries1 = new Set([0, 1]);
                        const boundaries2 = new Set([0, 1]);
                        for (const r of rects) {
                            boundaries1.add(r.s1);
                            boundaries1.add(r.e1);
                            boundaries2.add(r.s2);
                            boundaries2.add(r.e2);
                        }
                        const sorted1 = Array.from(boundaries1).sort((a, b) => a - b);
                        const sorted2 = Array.from(boundaries2).sort((a, b) => a - b);
                        
                        // Check each cell in the grid formed by these boundaries
                        for (let i = 0; i < sorted1.length - 1; i++) {
                            const cellMid1 = (sorted1[i] + sorted1[i + 1]) / 2;
                            for (let j = 0; j < sorted2.length - 1; j++) {
                                const cellMid2 = (sorted2[j] + sorted2[j + 1]) / 2;
                                
                                // Check if this cell's center is covered by any meshface
                                let covered = false;
                                for (const r of rects) {
                                    if (cellMid1 >= r.s1 - epsilon && cellMid1 <= r.e1 + epsilon &&
                                        cellMid2 >= r.s2 - epsilon && cellMid2 <= r.e2 + epsilon) {
                                        covered = true;
                                        break;
                                    }
                                }
                                if (!covered) return false; // Found a gap
                            }
                        }
                        return true; // All cells covered
                    };
                    
                    // Get unique constants for each axis
                    const uniqueU = new Set(), uniqueV = new Set(), uniqueW = new Set();
                    for (const face of iterateMeshfaces(mesh.meshfaces)) {
                        if (face.normalAxis === 'u') uniqueU.add(face.constant);
                        else if (face.normalAxis === 'v') uniqueV.add(face.constant);
                        else uniqueW.add(face.constant);
                    }
                    
                    // Draw U-normal plane inspection points at all four corners of the V-W plane
                    for (const u of uniqueU) {
                        const isSelected = inspectionPlane && inspectionPlane.normalAxis === 'u' && Math.abs(inspectionPlane.constant - u) < 1e-10;
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: isSelected ? 0xffc107 : 0xaaaaaa,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        // Four corners of the V-W plane
                        const corners = [
                            [u, offset, offset],
                            [u, far, offset],
                            [u, offset, far],
                            [u, far, far]
                        ];
                        
                        corners.forEach(pos => {
                            const sphere = new THREE.Mesh(inspSphereGeo, mat.clone());
                            sphere.position.set(...pos);
                            sphere.userData.isMeshObject = true;
                            sphere.userData.planeData = { normalAxis: 'u', constant: u };
                            scene.add(sphere);
                            inspectionPointsRef.current.push(sphere);
                        });
                    }
                    
                    // Draw V-normal plane inspection points at all four corners of the U-W plane
                    for (const v of uniqueV) {
                        const isSelected = inspectionPlane && inspectionPlane.normalAxis === 'v' && Math.abs(inspectionPlane.constant - v) < 1e-10;
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: isSelected ? 0xffc107 : 0xaaaaaa,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        // Four corners of the U-W plane
                        const corners = [
                            [offset, v, offset],
                            [far, v, offset],
                            [offset, v, far],
                            [far, v, far]
                        ];
                        
                        corners.forEach(pos => {
                            const sphere = new THREE.Mesh(inspSphereGeo, mat.clone());
                            sphere.position.set(...pos);
                            sphere.userData.isMeshObject = true;
                            sphere.userData.planeData = { normalAxis: 'v', constant: v };
                            scene.add(sphere);
                            inspectionPointsRef.current.push(sphere);
                        });
                    }
                    
                    // Draw W-normal plane inspection points at all four corners of the U-V plane
                    for (const w of uniqueW) {
                        const isSelected = inspectionPlane && inspectionPlane.normalAxis === 'w' && Math.abs(inspectionPlane.constant - w) < 1e-10;
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: isSelected ? 0xffc107 : 0xaaaaaa,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        // Four corners of the U-V plane
                        const corners = [
                            [offset, offset, w],
                            [far, offset, w],
                            [offset, far, w],
                            [far, far, w]
                        ];
                        
                        corners.forEach(pos => {
                            const sphere = new THREE.Mesh(inspSphereGeo, mat.clone());
                            sphere.position.set(...pos);
                            sphere.userData.isMeshObject = true;
                            sphere.userData.planeData = { normalAxis: 'w', constant: w };
                            scene.add(sphere);
                            inspectionPointsRef.current.push(sphere);
                        });
                    }
                }
                
                // Draw inspection plane with actual meshface coverage (element-level meshfaces)
                if (inspectionPlane) {
                    const { normalAxis, constant } = inspectionPlane;
                    
                    drawPlaneVisualization(normalAxis, constant, {
                        planeColor: 0x888888,
                        planeOpacity: 0.2,
                        gridColor: 0x000000,
                        showMeshfaceCoverage: true,
                        coverageColor: 0x4CAF50,  // Green to clearly show covered vs uncovered
                        coverageOpacity: 0.5,
                        showDashedOutline: false,
                        baseRenderOrder: 100
                    });
                }

            }, [mesh, selectedBSpline, showMeshfaces, showGreville, showElements, showBSplineSupports, refinementPoints, refinementStart, showRefinementPoints, inspectionPlane, showInspectionPoints]);

            return <div ref={containerRef} id="threejs-canvas" />;
        }

        /**
         * Main App Component
         */
        function App() {
            const [degreeU, setDegreeU] = useState(2);
            const [degreeV, setDegreeV] = useState(2);
            const [degreeW, setDegreeW] = useState(2);
            const [numElementsU, setNumElementsU] = useState(3);
            const [numElementsV, setNumElementsV] = useState(3);
            const [numElementsW, setNumElementsW] = useState(3);
            const [mesh, setMesh] = useState(() => createMesh3D(2, 2, 2, 3, 3, 3));
            const [selectedBSpline, setSelectedBSpline] = useState(null);
            const [menuVisible, setMenuVisible] = useState(true);
            
            // Visualization toggles
            const [showMeshfaces, setShowMeshfaces] = useState(false);
            const [showGreville, setShowGreville] = useState(true);
            const [showElements, setShowElements] = useState(true);
            const [showBSplineSupports, setShowBSplineSupports] = useState(false);
            const [showRefinementControls, setShowRefinementControls] = useState(false);
            const [showInspectionPoints, setShowInspectionPoints] = useState(false);
            
            // Inspection plane state (for debugging meshface coverage)
            const [inspectionPlane, setInspectionPlane] = useState(null);
            const [filterByInspectionPlane, setFilterByInspectionPlane] = useState(false);
            
            // Refinement state
            const [refAxis, setRefAxis] = useState('u');
            const [refinementStart, setRefinementStart] = useState(null);

            // Compute valid points based on current state
            const validStartPoints = useMemo(() => getValidStartPoints3D(mesh, refAxis), [mesh, refAxis]);
            const validEndPoints = useMemo(() => (
                refinementStart ? getValidEndPoints3D(mesh, refinementStart) : []
            ), [mesh, refinementStart]);
            
            // Filter points by selected B-spline and/or inspection plane
            const filterPointsByBSpline = (points) => {
                let filtered = points;
                const epsilon = 1e-10;
                
                // Filter by B-spline support if selected
                if (selectedBSpline) {
                    const bspline = mesh.bsplines.find(b => b.id === selectedBSpline);
                    if (bspline) {
                        const support = bspline.getSupport();
                        filtered = filtered.filter(p => 
                            p.u >= support.uMin - epsilon && p.u <= support.uMax + epsilon &&
                            p.v >= support.vMin - epsilon && p.v <= support.vMax + epsilon &&
                            p.w >= support.wMin - epsilon && p.w <= support.wMax + epsilon
                        );
                    }
                }
                
                // Filter by inspection plane if enabled and selected
                if (filterByInspectionPlane && inspectionPlane) {
                    const { normalAxis, constant } = inspectionPlane;
                    filtered = filtered.filter(p => {
                        const pointConstant = normalAxis === 'u' ? p.u : (normalAxis === 'v' ? p.v : p.w);
                        return Math.abs(pointConstant - constant) < epsilon;
                    });
                }
                
                return filtered;
            };
            
            // Current points to display (filtered by B-spline and/or inspection plane if selected)
            const refinementPoints = useMemo(() => {
                const points = refinementStart ? validEndPoints : validStartPoints;
                return filterPointsByBSpline(points);
            }, [refinementStart, validStartPoints, validEndPoints, selectedBSpline, mesh, filterByInspectionPlane, inspectionPlane]);

            const handleReset = () => {
                setMesh(createMesh3D(degreeU, degreeV, degreeW, numElementsU, numElementsV, numElementsW));
                setSelectedBSpline(null);
                setRefinementStart(null);
            };

            const handleAxisChange = (axis) => {
                setRefAxis(axis);
                setRefinementStart(null);
            };

            const handlePointClick = (point) => {
                if (!refinementStart) {
                    // Set start point
                    setRefinementStart(point);
                    return;
                }
                
                // We have start and now end - add the meshface
                const { normalAxis } = refinementStart;
                let span1Start, span1End, span2Start, span2End;
                let constant;
                
                if (normalAxis === 'u') {
                    constant = refinementStart.u;
                    span1Start = Math.min(refinementStart.v, point.v);
                    span1End = Math.max(refinementStart.v, point.v);
                    span2Start = Math.min(refinementStart.w, point.w);
                    span2End = Math.max(refinementStart.w, point.w);
                } else if (normalAxis === 'v') {
                    constant = refinementStart.v;
                    span1Start = Math.min(refinementStart.u, point.u);
                    span1End = Math.max(refinementStart.u, point.u);
                    span2Start = Math.min(refinementStart.w, point.w);
                    span2End = Math.max(refinementStart.w, point.w);
                } else {
                    constant = refinementStart.w;
                    span1Start = Math.min(refinementStart.u, point.u);
                    span1End = Math.max(refinementStart.u, point.u);
                    span2Start = Math.min(refinementStart.v, point.v);
                    span2End = Math.max(refinementStart.v, point.v);
                }
                
                const newMesh = addRefinement(mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End);
                setMesh(newMesh);
                setRefinementStart(null);
                setSelectedBSpline(null);
            };

            const handleCancelRefinement = () => {
                setRefinementStart(null);
            };
            
            const handleInspectionClick = (planeData) => {
                // Toggle inspection plane - click same plane to dismiss
                if (inspectionPlane && 
                    inspectionPlane.normalAxis === planeData.normalAxis &&
                    Math.abs(inspectionPlane.constant - planeData.constant) < 1e-10) {
                    setInspectionPlane(null);
                } else {
                    setInspectionPlane(planeData);
                }
            };

            const minElements = (deg) => deg + 1;

            return (
                <div className="container">
                    <button 
                        className={`menu-toggle ${menuVisible ? 'menu-visible' : ''}`}
                        onClick={() => setMenuVisible(true)}
                        title="Show menu">
                        
                    </button>
                    <div className={`controls ${menuVisible ? '' : 'hidden'}`}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                            <h2 style={{ margin: 0 }}>LR B-Spline 3D</h2>
                            <button 
                                onClick={() => setMenuVisible(false)}
                                style={{ 
                                    width: 'auto', 
                                    padding: '4px 12px', 
                                    margin: 0,
                                    fontSize: '18px'
                                }}
                                title="Hide menu (fullscreen)">
                                
                            </button>
                        </div>
                        
                        <div className="info">
                            Click Greville (green) to select B-splines. Click colored points outside cube to inspect meshface coverage on each plane.
                        </div>

                        <div className="stats">
                            <strong>Statistics:</strong><br />
                            B-splines: {mesh.bsplines.length}<br />
                            Meshfaces: {[...mesh.meshfaces.values()].reduce((sum, mfSet) => sum + mfSet.size, 0)}<br />
                            Elements: {mesh.elements.length}
                        </div>

                        <div className="control-group">
                            <label>Degree U: {degreeU}</label>
                            <input type="range" min="1" max="3" value={degreeU} 
                                onChange={(e) => setDegreeU(parseInt(e.target.value))} />
                            <label>Degree V: {degreeV}</label>
                            <input type="range" min="1" max="3" value={degreeV} 
                                onChange={(e) => setDegreeV(parseInt(e.target.value))} />
                            <label>Degree W: {degreeW}</label>
                            <input type="range" min="1" max="3" value={degreeW} 
                                onChange={(e) => setDegreeW(parseInt(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Elements U: {numElementsU}</label>
                            <input type="range" min={minElements(degreeU)} max="6" value={numElementsU} 
                                onChange={(e) => setNumElementsU(parseInt(e.target.value))} />
                            <label>Elements V: {numElementsV}</label>
                            <input type="range" min={minElements(degreeV)} max="6" value={numElementsV} 
                                onChange={(e) => setNumElementsV(parseInt(e.target.value))} />
                            <label>Elements W: {numElementsW}</label>
                            <input type="range" min={minElements(degreeW)} max="6" value={numElementsW} 
                                onChange={(e) => setNumElementsW(parseInt(e.target.value))} />
                        </div>

                        <button onClick={handleReset}>Reset Mesh</button>

                        <div className="control-group">
                            <button 
                                onClick={() => setShowRefinementControls(!showRefinementControls)}
                                style={{ 
                                    background: showRefinementControls ? '#28a745' : '#6c757d',
                                    marginBottom: showRefinementControls ? '10px' : '0'
                                }}>
                                {showRefinementControls ? ' Refinement Mode (Active)' : ' Refinement Mode'}
                            </button>
                            
                            {showRefinementControls && (
                                <div style={{ 
                                    background: '#f8f9fa', 
                                    padding: '10px', 
                                    borderRadius: '4px',
                                    border: '1px solid #28a745'
                                }}>
                                    <div style={{ fontSize: '12px', color: '#28a745', marginBottom: '8px' }}>
                                        {refinementStart 
                                            ? `Click end point to complete ${refAxis.toUpperCase()}-perp meshface`
                                            : `Click a blue point to start refinement`
                                        }
                                    </div>
                                    
                                    <label style={{ fontSize: '12px' }}>Direction (normal axis):</label>
                                    <div style={{ display: 'flex', gap: '5px', marginBottom: '8px' }}>
                                        {['u', 'v', 'w'].map(axis => (
                                            <button key={axis} 
                                                style={{ 
                                                    flex: 1, 
                                                    background: refAxis === axis ? '#005a9e' : '#007acc',
                                                    fontSize: '12px',
                                                    padding: '5px'
                                                }}
                                                onClick={() => handleAxisChange(axis)}>
                                                {axis.toUpperCase()}-perp
                                            </button>
                                        ))}
                                    </div>
                                    
                                    {refinementStart && (
                                        <div style={{ marginBottom: '8px' }}>
                                            <div style={{ fontSize: '11px', marginBottom: '5px' }}>
                                                Start: ({refinementStart.u.toFixed(2)}, {refinementStart.v.toFixed(2)}, {refinementStart.w.toFixed(2)})
                                            </div>
                                            <button onClick={handleCancelRefinement} style={{ background: '#dc3545', fontSize: '12px' }}>
                                                Cancel
                                            </button>
                                        </div>
                                    )}
                                    
                                    <div style={{ fontSize: '10px', color: '#666' }}>
                                        Available points: {refinementPoints.length}
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="control-group">
                            <label>Display Options:</label>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showMeshfaces" checked={showMeshfaces} 
                                    onChange={(e) => setShowMeshfaces(e.target.checked)} />
                                <label htmlFor="showMeshfaces">Meshfaces</label>
                            </div>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showGreville" checked={showGreville} 
                                    onChange={(e) => setShowGreville(e.target.checked)} />
                                <label htmlFor="showGreville">Greville Points</label>
                            </div>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showElements" checked={showElements} 
                                    onChange={(e) => setShowElements(e.target.checked)} />
                                <label htmlFor="showElements">Elements</label>
                            </div>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showSupports" checked={showBSplineSupports} 
                                    onChange={(e) => setShowBSplineSupports(e.target.checked)} />
                                <label htmlFor="showSupports">B-spline Supports</label>
                            </div>
                        </div>

                        <div className="control-group">
                            <button 
                                onClick={() => {
                                    const newState = !showInspectionPoints;
                                    setShowInspectionPoints(newState);
                                    if (!newState) {
                                        setInspectionPlane(null);
                                    }
                                }}
                                style={{ 
                                    background: showInspectionPoints ? '#ffc107' : '#6c757d',
                                    marginBottom: showInspectionPoints ? '10px' : '0'
                                }}>
                                {showInspectionPoints ? ' Inspection Mode (Active)' : ' Inspection Mode'}
                            </button>
                            
                            {showInspectionPoints && inspectionPlane && (
                                <div style={{ 
                                    background: '#fff8e1', 
                                    padding: '10px', 
                                    borderRadius: '4px',
                                    border: '1px solid #ffc107',
                                    marginBottom: '10px'
                                }}>
                                    <div style={{ fontSize: '12px', color: '#666', marginBottom: '8px' }}>
                                        Inspecting {inspectionPlane.normalAxis.toUpperCase()}-plane at {inspectionPlane.constant.toFixed(3)}
                                    </div>
                                    <div className="checkbox-group" style={{ marginBottom: '8px' }}>
                                        <input type="checkbox" id="filterByPlane" checked={filterByInspectionPlane} 
                                            onChange={(e) => setFilterByInspectionPlane(e.target.checked)} />
                                        <label htmlFor="filterByPlane" style={{ fontSize: '12px' }}>Restrict refinements to this plane</label>
                                    </div>
                                    <button 
                                        onClick={() => setInspectionPlane(null)}
                                        style={{ 
                                            fontSize: '12px', 
                                            padding: '4px 8px'
                                        }}>
                                        Clear Plane
                                    </button>
                                </div>
                            )}
                        </div>

                        <div className="control-group">
                            <label>B-splines (click to select):</label>
                            <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
                                {mesh.bsplines.map(bspline => (
                                    <div key={bspline.id}
                                        className={`bspline-item ${selectedBSpline === bspline.id ? 'selected' : ''}`}
                                        onClick={() => setSelectedBSpline(selectedBSpline === bspline.id ? null : bspline.id)}>
                                        u:[{bspline.knotsU.map(k => k.toFixed(2)).join(',')}]<br/>
                                        v:[{bspline.knotsV.map(k => k.toFixed(2)).join(',')}]<br/>
                                        w:[{bspline.knotsW.map(k => k.toFixed(2)).join(',')}]
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="visualization">
                        <ThreeVisualization 
                            mesh={mesh}
                            selectedBSpline={selectedBSpline}
                            showMeshfaces={showMeshfaces}
                            showGreville={showGreville}
                            showElements={showElements}
                            showBSplineSupports={showBSplineSupports}
                            refinementPoints={refinementPoints}
                            refinementStart={refinementStart}
                            onPointClick={handlePointClick}
                            onGrevilleClick={(id) => {
                                if (selectedBSpline === id) {
                                    setSelectedBSpline(null);
                                } else {
                                    setSelectedBSpline(id);
                                    setShowBSplineSupports(true);
                                }
                            }}
                            showRefinementPoints={showRefinementControls}
                            inspectionPlane={inspectionPlane}
                            onInspectionClick={handleInspectionClick}
                            showInspectionPoints={showInspectionPoints}
                        />
                    </div>
                </div>
            );
        }

        // Wait for THREE to be loaded before rendering
        const renderApp = () => {
            ReactDOM.render(<App />, document.getElementById('root'));
        };
        
        if (window.THREE) {
            renderApp();
        } else {
            window.addEventListener('three-loaded', renderApp);
        }
    </script>
</body>
</html>