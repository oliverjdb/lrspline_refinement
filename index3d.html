<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LR B-Spline Refinement Visualization (3D)</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .controls {
            width: 320px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .visualization {
            flex: 1;
            position: relative;
        }
        #threejs-canvas {
            width: 100%;
            height: 100%;
        }
        h2 {
            margin-top: 0;
            color: #333;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-weight: 500;
            font-size: 13px;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        button {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            background: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover {
            background: #005a9e;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .info {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
            color: #1976d2;
            margin-bottom: 15px;
        }
        .stats {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #333;
            margin-bottom: 15px;
        }
        .bspline-item {
            padding: 4px 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            font-family: monospace;
        }
        .bspline-item:hover {
            background: #f0f0f0;
        }
        .bspline-item.selected {
            border-color: #007acc;
            background: #e3f2fd;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .checkbox-group input {
            width: auto;
            margin: 0;
        }
        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Make THREE available globally for the Babel script
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;
        
        // Signal that Three.js is loaded
        window.dispatchEvent(new Event('three-loaded'));
    </script>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect, useRef } = React;

        let nextBSplineId = 0;
        const generateBSplineId = () => nextBSplineId++;
        const resetBSplineIdCounter = () => { nextBSplineId = 0; };

        /**
         * LRBSpline3D class - represents a single LR B-spline in 3D
         * Knot vectors have distinct values (no multiplicity)
         */
        class LRBSpline3D {
            constructor(knotsU, knotsV, knotsW, id = null) {
                this.id = id !== null ? id : generateBSplineId();
                this.knotsU = [...knotsU];
                this.knotsV = [...knotsV];
                this.knotsW = [...knotsW];
            }

            /**
             * Get the support of this B-spline (3D bounding box)
             */
            getSupport() {
                return {
                    uMin: this.knotsU[0],
                    uMax: this.knotsU[this.knotsU.length - 1],
                    vMin: this.knotsV[0],
                    vMax: this.knotsV[this.knotsV.length - 1],
                    wMin: this.knotsW[0],
                    wMax: this.knotsW[this.knotsW.length - 1]
                };
            }

            /**
             * Calculate the Greville point (average of interior knots) in 3D
             * For degree p with p+2 knots, Greville point is average of middle p knots
             */
            getGrevillePoint() {
                const degreeU = this.knotsU.length - 2;
                const degreeV = this.knotsV.length - 2;
                const degreeW = this.knotsW.length - 2;
                
                // Average of interior knots (exclude first and last)
                let u = 0;
                for (let i = 1; i <= degreeU; i++) {
                    u += this.knotsU[i];
                }
                u /= degreeU;
                
                let v = 0;
                for (let i = 1; i <= degreeV; i++) {
                    v += this.knotsV[i];
                }
                v /= degreeV;
                
                let w = 0;
                for (let i = 1; i <= degreeW; i++) {
                    w += this.knotsW[i];
                }
                w /= degreeW;
                
                return { u, v, w };
            }

            /**
             * Split B-spline by inserting a new knot in U direction
             * Returns two new B-splines
             */
            splitU(newKnot) {
                const epsilon = 1e-10;
                const degreeU = this.knotsU.length - 2;
                
                const newKnotsU = [...this.knotsU];
                let insertIdx = newKnotsU.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsU.length;
                newKnotsU.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline3D(
                    newKnotsU.slice(0, degreeU + 2),
                    this.knotsV,
                    this.knotsW
                );
                const bspline2 = new LRBSpline3D(
                    newKnotsU.slice(1, degreeU + 3),
                    this.knotsV,
                    this.knotsW
                );
                
                return [bspline1, bspline2];
            }

            /**
             * Split B-spline by inserting a new knot in V direction
             * Returns two new B-splines
             */
            splitV(newKnot) {
                const epsilon = 1e-10;
                const degreeV = this.knotsV.length - 2;
                
                const newKnotsV = [...this.knotsV];
                let insertIdx = newKnotsV.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsV.length;
                newKnotsV.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline3D(
                    this.knotsU,
                    newKnotsV.slice(0, degreeV + 2),
                    this.knotsW
                );
                const bspline2 = new LRBSpline3D(
                    this.knotsU,
                    newKnotsV.slice(1, degreeV + 3),
                    this.knotsW
                );
                
                return [bspline1, bspline2];
            }

            /**
             * Split B-spline by inserting a new knot in W direction
             * Returns two new B-splines
             */
            splitW(newKnot) {
                const epsilon = 1e-10;
                const degreeW = this.knotsW.length - 2;
                
                const newKnotsW = [...this.knotsW];
                let insertIdx = newKnotsW.findIndex(k => k > newKnot - epsilon);
                if (insertIdx === -1) insertIdx = newKnotsW.length;
                newKnotsW.splice(insertIdx, 0, newKnot);
                
                const bspline1 = new LRBSpline3D(
                    this.knotsU,
                    this.knotsV,
                    newKnotsW.slice(0, degreeW + 2)
                );
                const bspline2 = new LRBSpline3D(
                    this.knotsU,
                    this.knotsV,
                    newKnotsW.slice(1, degreeW + 3)
                );
                
                return [bspline1, bspline2];
            }
        }

        /**
         * Meshface class - represents a single mesh face (plane segment) in the 3D LR mesh
         * 
         * In 3D, meshlines become mesh faces (rectangular planar regions).
         * Each face is perpendicular to one of the axes (U, V, or W).
         * 
         * - normalAxis: 'u', 'v', or 'w' - the axis perpendicular to this face
         * - constant: the fixed coordinate along the normal axis
         * - For a face perpendicular to U (normalAxis='u'):
         *   - constant = u position
         *   - The face spans [vStart, vEnd] x [wStart, wEnd]
         * - For a face perpendicular to V (normalAxis='v'):
         *   - constant = v position
         *   - The face spans [uStart, uEnd] x [wStart, wEnd]
         * - For a face perpendicular to W (normalAxis='w'):
         *   - constant = w position
         *   - The face spans [uStart, uEnd] x [vStart, vEnd]
         */
        class Meshface {
            constructor(normalAxis, constant, span1Start, span1End, span2Start, span2End, id) {
                this.normalAxis = normalAxis;  // 'u', 'v', or 'w'
                this.constant = constant;      // the fixed coordinate along normalAxis
                this.id = id;                  // unique identifier
                
                // Store spans based on normal axis
                // We use a consistent naming: first span is the "lower" axis, second is "higher"
                // u < v < w in terms of ordering
                if (normalAxis === 'u') {
                    // Face perpendicular to U: spans V and W
                    this.vStart = span1Start;
                    this.vEnd = span1End;
                    this.wStart = span2Start;
                    this.wEnd = span2End;
                } else if (normalAxis === 'v') {
                    // Face perpendicular to V: spans U and W
                    this.uStart = span1Start;
                    this.uEnd = span1End;
                    this.wStart = span2Start;
                    this.wEnd = span2End;
                } else { // normalAxis === 'w'
                    // Face perpendicular to W: spans U and V
                    this.uStart = span1Start;
                    this.uEnd = span1End;
                    this.vStart = span2Start;
                    this.vEnd = span2End;
                }
            }

            /**
             * Get the spans of this face in the two directions it spans
             * Returns { axis1, start1, end1, axis2, start2, end2 }
             */
            getSpans() {
                if (this.normalAxis === 'u') {
                    return {
                        axis1: 'v', start1: this.vStart, end1: this.vEnd,
                        axis2: 'w', start2: this.wStart, end2: this.wEnd
                    };
                } else if (this.normalAxis === 'v') {
                    return {
                        axis1: 'u', start1: this.uStart, end1: this.uEnd,
                        axis2: 'w', start2: this.wStart, end2: this.wEnd
                    };
                } else {
                    return {
                        axis1: 'u', start1: this.uStart, end1: this.uEnd,
                        axis2: 'v', start2: this.vStart, end2: this.vEnd
                    };
                }
            }

            /**
             * Get the bounding box of this face
             */
            getBounds() {
                if (this.normalAxis === 'u') {
                    return {
                        uMin: this.constant, uMax: this.constant,
                        vMin: this.vStart, vMax: this.vEnd,
                        wMin: this.wStart, wMax: this.wEnd
                    };
                } else if (this.normalAxis === 'v') {
                    return {
                        uMin: this.uStart, uMax: this.uEnd,
                        vMin: this.constant, vMax: this.constant,
                        wMin: this.wStart, wMax: this.wEnd
                    };
                } else {
                    return {
                        uMin: this.uStart, uMax: this.uEnd,
                        vMin: this.vStart, vMax: this.vEnd,
                        wMin: this.constant, wMax: this.constant
                    };
                }
            }

            /**
             * Check if this face contains a point (u, v, w)
             */
            containsPoint(u, v, w) {
                const epsilon = 1e-10;
                const bounds = this.getBounds();
                
                return u >= bounds.uMin - epsilon && u <= bounds.uMax + epsilon &&
                       v >= bounds.vMin - epsilon && v <= bounds.vMax + epsilon &&
                       w >= bounds.wMin - epsilon && w <= bounds.wMax + epsilon;
            }

            /**
             * Check if this face fully covers another face's extent
             * (used for merging adjacent/overlapping faces)
             */
            covers(other) {
                if (this.normalAxis !== other.normalAxis) return false;
                
                const epsilon = 1e-10;
                if (Math.abs(this.constant - other.constant) > epsilon) return false;
                
                const thisSpans = this.getSpans();
                const otherSpans = other.getSpans();
                
                return thisSpans.start1 <= otherSpans.start1 + epsilon &&
                       thisSpans.end1 >= otherSpans.end1 - epsilon &&
                       thisSpans.start2 <= otherSpans.start2 + epsilon &&
                       thisSpans.end2 >= otherSpans.end2 - epsilon;
            }
        }

        /**
         * Check if a meshface exists at the given position that covers the specified region
         */
        const meshfaceExists = (mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            return mesh.meshfaces.some(face => {
                if (face.normalAxis !== normalAxis) return false;
                if (Math.abs(face.constant - constant) > epsilon) return false;
                
                const spans = face.getSpans();
                return spans.start1 <= span1Start + epsilon &&
                       spans.end1 >= span1End - epsilon &&
                       spans.start2 <= span2Start + epsilon &&
                       spans.end2 >= span2End - epsilon;
            });
        };

        /**
         * Try to merge a new meshface with existing coplanar meshfaces
         * This handles extending T-junctions in 3D
         * Returns { meshfaces, wasNewFace }
         */
        const mergeOrAddMeshface = (meshfaces, normalAxis, constant, span1Start, span1End, span2Start, span2End, nextId) => {
            const epsilon = 1e-10;
            const nonCoplanar = [];
            const coplanar = [];
            
            // Separate coplanar and non-coplanar meshfaces
            for (const face of meshfaces) {
                if (face.normalAxis === normalAxis && 
                    Math.abs(face.constant - constant) < epsilon) {
                    coplanar.push(face);
                } else {
                    nonCoplanar.push(face);
                }
            }
            
            // Start with the new face region
            let mergedSpan1Start = span1Start;
            let mergedSpan1End = span1End;
            let mergedSpan2Start = span2Start;
            let mergedSpan2End = span2End;
            let mergedId = nextId;
            let anyMerged = false;
            const keptCoplanar = [];
            
            // Try to merge with each coplanar face
            // Two faces can merge ONLY if they share a complete edge:
            // - Same extent in one span direction AND adjacent/overlapping in the other, OR
            // - One face completely contains the other
            for (const face of coplanar) {
                const spans = face.getSpans();
                
                // Check for complete edge sharing or containment
                // Case 1: Same span1 extent, adjacent/overlapping in span2
                const sameSpan1 = Math.abs(mergedSpan1Start - spans.start1) < epsilon &&
                                 Math.abs(mergedSpan1End - spans.end1) < epsilon;
                const adjacentSpan2 = mergedSpan2Start <= spans.end2 + epsilon && 
                                     mergedSpan2End >= spans.start2 - epsilon;
                
                // Case 2: Same span2 extent, adjacent/overlapping in span1
                const sameSpan2 = Math.abs(mergedSpan2Start - spans.start2) < epsilon &&
                                 Math.abs(mergedSpan2End - spans.end2) < epsilon;
                const adjacentSpan1 = mergedSpan1Start <= spans.end1 + epsilon && 
                                     mergedSpan1End >= spans.start1 - epsilon;
                
                // Case 3: One contains the other (subset case)
                const newContainsOld = mergedSpan1Start <= spans.start1 + epsilon &&
                                      mergedSpan1End >= spans.end1 - epsilon &&
                                      mergedSpan2Start <= spans.start2 + epsilon &&
                                      mergedSpan2End >= spans.end2 - epsilon;
                const oldContainsNew = spans.start1 <= mergedSpan1Start + epsilon &&
                                      spans.end1 >= mergedSpan1End - epsilon &&
                                      spans.start2 <= mergedSpan2Start + epsilon &&
                                      spans.end2 >= mergedSpan2End - epsilon;
                
                const canMerge = (sameSpan1 && adjacentSpan2) || 
                                (sameSpan2 && adjacentSpan1) ||
                                newContainsOld || oldContainsNew;
                
                if (canMerge) {
                    // Merge by taking the union
                    mergedSpan1Start = Math.min(mergedSpan1Start, spans.start1);
                    mergedSpan1End = Math.max(mergedSpan1End, spans.end1);
                    mergedSpan2Start = Math.min(mergedSpan2Start, spans.start2);
                    mergedSpan2End = Math.max(mergedSpan2End, spans.end2);
                    if (!anyMerged) {
                        mergedId = face.id; // Keep the first merged face's ID
                    }
                    anyMerged = true;
                } else {
                    // Keep this face separate
                    keptCoplanar.push(face);
                }
            }
            
            // Build result
            const result = [
                ...nonCoplanar,
                ...keptCoplanar,
                new Meshface(normalAxis, constant, mergedSpan1Start, mergedSpan1End, mergedSpan2Start, mergedSpan2End, mergedId)
            ];
            
            return { meshfaces: result, wasNewFace: !anyMerged };
        };

        /**
         * Count how many times a knot value appears in a knot vector
         */
        const countKnotInVector = (knotVector, knotValue) => {
            const epsilon = 1e-10;
            let count = 0;
            for (const k of knotVector) {
                if (Math.abs(k - knotValue) < epsilon) {
                    count++;
                }
            }
            return count;
        };

        /**
         * Check if two meshfaces are adjacent (share a complete edge)
         * For proper LR-spline semantics, faces must share a complete edge to be connected:
         * - Same extent in one span direction AND overlapping in the other, OR
         * - One contains the other
         */
        const facesAreAdjacent = (face1, face2) => {
            const epsilon = 1e-10;
            const spans1 = face1.getSpans();
            const spans2 = face2.getSpans();
            
            // Check for complete edge sharing
            // Case 1: Same span1 extent, adjacent/overlapping in span2
            const sameSpan1 = Math.abs(spans1.start1 - spans2.start1) < epsilon &&
                             Math.abs(spans1.end1 - spans2.end1) < epsilon;
            const adjacentSpan2 = spans1.start2 <= spans2.end2 + epsilon && 
                                 spans1.end2 >= spans2.start2 - epsilon;
            
            // Case 2: Same span2 extent, adjacent/overlapping in span1
            const sameSpan2 = Math.abs(spans1.start2 - spans2.start2) < epsilon &&
                             Math.abs(spans1.end2 - spans2.end2) < epsilon;
            const adjacentSpan1 = spans1.start1 <= spans2.end1 + epsilon && 
                                 spans1.end1 >= spans2.start1 - epsilon;
            
            // Case 3: One contains the other (subset case)
            const oneContainsOther = (
                (spans1.start1 <= spans2.start1 + epsilon && spans1.end1 >= spans2.end1 - epsilon &&
                 spans1.start2 <= spans2.start2 + epsilon && spans1.end2 >= spans2.end2 - epsilon) ||
                (spans2.start1 <= spans1.start1 + epsilon && spans2.end1 >= spans1.end1 - epsilon &&
                 spans2.start2 <= spans1.start2 + epsilon && spans2.end2 >= spans1.end2 - epsilon)
            );
            
            return (sameSpan1 && adjacentSpan2) || (sameSpan2 && adjacentSpan1) || oneContainsOther;
        };

        /**
         * Find connected components of coplanar meshfaces
         * Returns array of arrays, each inner array is a connected component
         */
        const findConnectedFaceComponents = (faces) => {
            if (faces.length === 0) return [];
            
            const visited = new Set();
            const components = [];
            
            for (const face of faces) {
                if (visited.has(face.id)) continue;
                
                // BFS to find all connected faces
                const component = [];
                const queue = [face];
                visited.add(face.id);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    
                    for (const other of faces) {
                        if (!visited.has(other.id) && facesAreAdjacent(current, other)) {
                            visited.add(other.id);
                            queue.push(other);
                        }
                    }
                }
                
                components.push(component);
            }
            
            return components;
        };

        /**
         * Compute the bounding box of a connected component of meshfaces
         * Returns the union bounding box in span1 and span2 directions
         */
        const getComponentBoundingBox = (component) => {
            if (component.length === 0) return null;
            
            const first = component[0].getSpans();
            let minSpan1 = first.start1, maxSpan1 = first.end1;
            let minSpan2 = first.start2, maxSpan2 = first.end2;
            
            for (const face of component) {
                const spans = face.getSpans();
                minSpan1 = Math.min(minSpan1, spans.start1);
                maxSpan1 = Math.max(maxSpan1, spans.end1);
                minSpan2 = Math.min(minSpan2, spans.start2);
                maxSpan2 = Math.max(maxSpan2, spans.end2);
            }
            
            return {
                span1Start: minSpan1, span1End: maxSpan1,
                span2Start: minSpan2, span2End: maxSpan2,
                normalAxis: component[0].normalAxis,
                constant: component[0].constant
            };
        };

        /**
         * Check if a connected component of meshfaces splits a B-spline
         * The component splits a B-spline if:
         * 1. The constant coordinate is strictly inside the B-spline's support
         * 2. The component's bounding box spans the entire B-spline support in the other directions
         * 3. The knot value doesn't already exist in the B-spline's local knot vector
         */
        const componentSplitsBSpline = (component, bspline, multiplicity = 1) => {
            const epsilon = 1e-10;
            const bbox = getComponentBoundingBox(component);
            if (!bbox) return false;
            
            const support = bspline.getSupport();
            const { normalAxis, constant, span1Start, span1End, span2Start, span2End } = bbox;
            
            if (normalAxis === 'u') {
                const uInside = constant > support.uMin + epsilon && 
                               constant < support.uMax - epsilon;
                const vSpans = span1Start <= support.vMin + epsilon && 
                              span1End >= support.vMax - epsilon;
                const wSpans = span2Start <= support.wMin + epsilon && 
                              span2End >= support.wMax - epsilon;
                
                if (!uInside || !vSpans || !wSpans) return false;
                
                const nKnots = countKnotInVector(bspline.knotsU, constant);
                return nKnots < multiplicity;
                
            } else if (normalAxis === 'v') {
                const vInside = constant > support.vMin + epsilon && 
                               constant < support.vMax - epsilon;
                const uSpans = span1Start <= support.uMin + epsilon && 
                              span1End >= support.uMax - epsilon;
                const wSpans = span2Start <= support.wMin + epsilon && 
                              span2End >= support.wMax - epsilon;
                
                if (!vInside || !uSpans || !wSpans) return false;
                
                const nKnots = countKnotInVector(bspline.knotsV, constant);
                return nKnots < multiplicity;
                
            } else { // normalAxis === 'w'
                const wInside = constant > support.wMin + epsilon && 
                               constant < support.wMax - epsilon;
                const uSpans = span1Start <= support.uMin + epsilon && 
                              span1End >= support.uMax - epsilon;
                const vSpans = span2Start <= support.vMin + epsilon && 
                              span2End >= support.vMax - epsilon;
                
                if (!wInside || !uSpans || !vSpans) return false;
                
                const nKnots = countKnotInVector(bspline.knotsW, constant);
                return nKnots < multiplicity;
            }
        };

        /**
         * Check if a meshface splits a B-spline
         * A meshface splits a B-spline if:
         * 1. The constant coordinate is strictly inside the B-spline's support in that direction
         * 2. The meshface spans the entire support of the B-spline in the other two directions
         * 3. The knot value doesn't already exist in the B-spline's local knot vector
         */
        const meshfaceSplitsBSpline = (meshface, bspline, multiplicity = 1) => {
            const epsilon = 1e-10;
            const support = bspline.getSupport();
            
            if (meshface.normalAxis === 'u') {
                // Face perpendicular to U: check if u is strictly inside
                const uInside = meshface.constant > support.uMin + epsilon && 
                               meshface.constant < support.uMax - epsilon;
                // Check if face spans the entire v and w support
                const vSpans = meshface.vStart <= support.vMin + epsilon && 
                              meshface.vEnd >= support.vMax - epsilon;
                const wSpans = meshface.wStart <= support.wMin + epsilon && 
                              meshface.wEnd >= support.wMax - epsilon;
                
                if (!uInside || !vSpans || !wSpans) return false;
                
                // Check if the knot already exists
                const nKnots = countKnotInVector(bspline.knotsU, meshface.constant);
                return nKnots < multiplicity;
                
            } else if (meshface.normalAxis === 'v') {
                // Face perpendicular to V: check if v is strictly inside
                const vInside = meshface.constant > support.vMin + epsilon && 
                               meshface.constant < support.vMax - epsilon;
                // Check if face spans the entire u and w support
                const uSpans = meshface.uStart <= support.uMin + epsilon && 
                              meshface.uEnd >= support.uMax - epsilon;
                const wSpans = meshface.wStart <= support.wMin + epsilon && 
                              meshface.wEnd >= support.wMax - epsilon;
                
                if (!vInside || !uSpans || !wSpans) return false;
                
                // Check if the knot already exists
                const nKnots = countKnotInVector(bspline.knotsV, meshface.constant);
                return nKnots < multiplicity;
                
            } else { // normalAxis === 'w'
                // Face perpendicular to W: check if w is strictly inside
                const wInside = meshface.constant > support.wMin + epsilon && 
                               meshface.constant < support.wMax - epsilon;
                // Check if face spans the entire u and v support
                const uSpans = meshface.uStart <= support.uMin + epsilon && 
                              meshface.uEnd >= support.uMax - epsilon;
                const vSpans = meshface.vStart <= support.vMin + epsilon && 
                              meshface.vEnd >= support.vMax - epsilon;
                
                if (!wInside || !uSpans || !vSpans) return false;
                
                // Check if the knot already exists
                const nKnots = countKnotInVector(bspline.knotsW, meshface.constant);
                return nKnots < multiplicity;
            }
        };

        /**
         * Split a B-spline by a meshface and return the resulting B-splines
         */
        const splitBSplineByMeshface = (bspline, meshface) => {
            if (meshface.normalAxis === 'u') {
                return bspline.splitU(meshface.constant);
            } else if (meshface.normalAxis === 'v') {
                return bspline.splitV(meshface.constant);
            } else {
                return bspline.splitW(meshface.constant);
            }
        };

        /**
         * Check if two 3D B-splines are identical (same knot vectors)
         */
        const areBSplines3DEqual = (bspline1, bspline2) => {
            const epsilon = 1e-10;
            
            if (bspline1.knotsU.length !== bspline2.knotsU.length ||
                bspline1.knotsV.length !== bspline2.knotsV.length ||
                bspline1.knotsW.length !== bspline2.knotsW.length) {
                return false;
            }
            
            for (let i = 0; i < bspline1.knotsU.length; i++) {
                if (Math.abs(bspline1.knotsU[i] - bspline2.knotsU[i]) > epsilon) {
                    return false;
                }
            }
            
            for (let i = 0; i < bspline1.knotsV.length; i++) {
                if (Math.abs(bspline1.knotsV[i] - bspline2.knotsV[i]) > epsilon) {
                    return false;
                }
            }
            
            for (let i = 0; i < bspline1.knotsW.length; i++) {
                if (Math.abs(bspline1.knotsW[i] - bspline2.knotsW[i]) > epsilon) {
                    return false;
                }
            }
            
            return true;
        };

        /**
         * Remove duplicate 3D B-splines from the list
         */
        const removeDuplicateBSplines3D = (bsplines) => {
            const unique = [];
            
            for (const bspline of bsplines) {
                const isDuplicate = unique.some(existing => areBSplines3DEqual(existing, bspline));
                if (!isDuplicate) {
                    unique.push(bspline);
                }
            }
            
            return unique;
        };

        /**
         * Element3D class - represents a 3D element (hexahedral box) in the LR mesh
         * Elements are axis-aligned boxes defined by their min/max coordinates
         */
        class Element3D {
            constructor(uMin, uMax, vMin, vMax, wMin, wMax) {
                this.uMin = uMin;
                this.uMax = uMax;
                this.vMin = vMin;
                this.vMax = vMax;
                this.wMin = wMin;
                this.wMax = wMax;
            }

            /**
             * Get the center point of this element
             */
            getCenter() {
                return {
                    u: (this.uMin + this.uMax) / 2,
                    v: (this.vMin + this.vMax) / 2,
                    w: (this.wMin + this.wMax) / 2
                };
            }

            /**
             * Get the dimensions of this element
             */
            getDimensions() {
                return {
                    du: this.uMax - this.uMin,
                    dv: this.vMax - this.vMin,
                    dw: this.wMax - this.wMin
                };
            }

            /**
             * Get the volume of this element
             */
            getVolume() {
                const dims = this.getDimensions();
                return dims.du * dims.dv * dims.dw;
            }

            /**
             * Check if a point is inside this element
             */
            containsPoint(u, v, w) {
                const epsilon = 1e-10;
                return u >= this.uMin - epsilon && u <= this.uMax + epsilon &&
                       v >= this.vMin - epsilon && v <= this.vMax + epsilon &&
                       w >= this.wMin - epsilon && w <= this.wMax + epsilon;
            }

            /**
             * Check if this element is contained within a B-spline's support
             */
            isContainedInSupport(support) {
                const epsilon = 1e-10;
                return support.uMin <= this.uMin + epsilon &&
                       support.uMax >= this.uMax - epsilon &&
                       support.vMin <= this.vMin + epsilon &&
                       support.vMax >= this.vMax - epsilon &&
                       support.wMin <= this.wMin + epsilon &&
                       support.wMax >= this.wMax - epsilon;
            }

            /**
             * Check if a meshface passes through the interior of this element
             * (can split the element)
             */
            isSplitByMeshface(meshface) {
                const epsilon = 1e-10;
                
                if (meshface.normalAxis === 'u') {
                    // Face perpendicular to U: check if constant is strictly inside u range
                    // and face spans the element's v and w extent
                    const uInside = meshface.constant > this.uMin + epsilon && 
                                   meshface.constant < this.uMax - epsilon;
                    const vSpans = meshface.vStart <= this.vMin + epsilon && 
                                  meshface.vEnd >= this.vMax - epsilon;
                    const wSpans = meshface.wStart <= this.wMin + epsilon && 
                                  meshface.wEnd >= this.wMax - epsilon;
                    return uInside && vSpans && wSpans;
                    
                } else if (meshface.normalAxis === 'v') {
                    // Face perpendicular to V
                    const vInside = meshface.constant > this.vMin + epsilon && 
                                   meshface.constant < this.vMax - epsilon;
                    const uSpans = meshface.uStart <= this.uMin + epsilon && 
                                  meshface.uEnd >= this.uMax - epsilon;
                    const wSpans = meshface.wStart <= this.wMin + epsilon && 
                                  meshface.wEnd >= this.wMax - epsilon;
                    return vInside && uSpans && wSpans;
                    
                } else { // normalAxis === 'w'
                    // Face perpendicular to W
                    const wInside = meshface.constant > this.wMin + epsilon && 
                                   meshface.constant < this.wMax - epsilon;
                    const uSpans = meshface.uStart <= this.uMin + epsilon && 
                                  meshface.uEnd >= this.uMax - epsilon;
                    const vSpans = meshface.vStart <= this.vMin + epsilon && 
                                  meshface.vEnd >= this.vMax - epsilon;
                    return wInside && uSpans && vSpans;
                }
            }

            /**
             * Split this element by a meshface
             * Returns two new elements if split occurs, otherwise returns [this]
             */
            splitByMeshface(meshface) {
                if (!this.isSplitByMeshface(meshface)) {
                    return [this];
                }
                
                if (meshface.normalAxis === 'u') {
                    return [
                        new Element3D(this.uMin, meshface.constant, this.vMin, this.vMax, this.wMin, this.wMax),
                        new Element3D(meshface.constant, this.uMax, this.vMin, this.vMax, this.wMin, this.wMax)
                    ];
                } else if (meshface.normalAxis === 'v') {
                    return [
                        new Element3D(this.uMin, this.uMax, this.vMin, meshface.constant, this.wMin, this.wMax),
                        new Element3D(this.uMin, this.uMax, meshface.constant, this.vMax, this.wMin, this.wMax)
                    ];
                } else {
                    return [
                        new Element3D(this.uMin, this.uMax, this.vMin, this.vMax, this.wMin, meshface.constant),
                        new Element3D(this.uMin, this.uMax, this.vMin, this.vMax, meshface.constant, this.wMax)
                    ];
                }
            }

            /**
             * Create a plain object representation (for compatibility)
             */
            toObject() {
                return {
                    uMin: this.uMin,
                    uMax: this.uMax,
                    vMin: this.vMin,
                    vMax: this.vMax,
                    wMin: this.wMin,
                    wMax: this.wMax
                };
            }
        }

        /**
         * Get T-junction edges from meshfaces in 3D
         * A T-junction occurs when a meshface edge doesn't extend to the domain boundary
         * Returns points along these edges that can be used to extend the meshface
         */
        const getTJunctionPoints3D = (mesh, normalAxis) => {
            const epsilon = 1e-10;
            const points = [];
            
            const knotsU = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
            const knotsV = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            const knotsW = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            
            const pointExists = (u, v, w) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon && 
                    Math.abs(p.w - w) < epsilon
                );
            };
            
            // Find meshfaces with the specified normal axis that have T-junction edges
            for (const face of mesh.meshfaces) {
                if (face.normalAxis !== normalAxis) continue;
                
                if (normalAxis === 'u') {
                    const u = face.constant;
                    // Check V edges (at vStart and vEnd)
                    // If vStart > 0, this is a T-junction edge - can extend downward in V
                    if (face.vStart > epsilon) {
                        // Points along this edge at W knot positions
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(u, face.vStart, w)) {
                                    points.push({ u, v: face.vStart, w, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                    // If vEnd < 1, this is a T-junction edge - can extend upward in V
                    if (face.vEnd < 1 - epsilon) {
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(u, face.vEnd, w)) {
                                    points.push({ u, v: face.vEnd, w, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                    // Check W edges (at wStart and wEnd)
                    if (face.wStart > epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(u, v, face.wStart)) {
                                    points.push({ u, v, w: face.wStart, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.wEnd < 1 - epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(u, v, face.wEnd)) {
                                    points.push({ u, v, w: face.wEnd, normalAxis: 'u', isTJunction: true });
                                }
                            }
                        }
                    }
                } else if (normalAxis === 'v') {
                    const v = face.constant;
                    // Check U edges
                    if (face.uStart > epsilon) {
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(face.uStart, v, w)) {
                                    points.push({ u: face.uStart, v, w, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.uEnd < 1 - epsilon) {
                        for (const w of knotsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                if (!pointExists(face.uEnd, v, w)) {
                                    points.push({ u: face.uEnd, v, w, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                    // Check W edges
                    if (face.wStart > epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, v, face.wStart)) {
                                    points.push({ u, v, w: face.wStart, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.wEnd < 1 - epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, v, face.wEnd)) {
                                    points.push({ u, v, w: face.wEnd, normalAxis: 'v', isTJunction: true });
                                }
                            }
                        }
                    }
                } else { // normalAxis === 'w'
                    const w = face.constant;
                    // Check U edges
                    if (face.uStart > epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(face.uStart, v, w)) {
                                    points.push({ u: face.uStart, v, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.uEnd < 1 - epsilon) {
                        for (const v of knotsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                if (!pointExists(face.uEnd, v, w)) {
                                    points.push({ u: face.uEnd, v, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                    // Check V edges
                    if (face.vStart > epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, face.vStart, w)) {
                                    points.push({ u, v: face.vStart, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                    if (face.vEnd < 1 - epsilon) {
                        for (const u of knotsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                if (!pointExists(u, face.vEnd, w)) {
                                    points.push({ u, v: face.vEnd, w, normalAxis: 'w', isTJunction: true });
                                }
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Get valid start points for refinement in 3D
         * A valid start point is on an existing meshface where a new perpendicular meshface can begin
         * 
         * For a refinement with normal axis 'axis', valid start points are on meshfaces 
         * perpendicular to one of the OTHER two axes, at positions where the 'axis' coordinate
         * lies between existing knots.
         * 
         * Also includes T-junction points for extending existing local refinements.
         * 
         * Returns array of { u, v, w, normalAxis } where normalAxis is the axis for the new meshface
         */
        const getValidStartPoints3D = (mesh, normalAxis) => {
            const epsilon = 1e-10;
            const points = [];
            
            const pointExists = (u, v, w) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon && 
                    Math.abs(p.w - w) < epsilon
                );
            };
            
            // Get global knots for each axis
            const knotsU = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
            const knotsV = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            const knotsW = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            
            // For normal axis 'u', we need points where u is at a midpoint between knots
            // and the point lies on existing meshfaces perpendicular to V or W
            if (normalAxis === 'u') {
                // Find midpoints in U direction
                const midpointsU = [];
                for (let i = 0; i < knotsU.length - 1; i++) {
                    midpointsU.push((knotsU[i] + knotsU[i + 1]) / 2);
                }
                
                // Look for points on V-perpendicular meshfaces
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'v') {
                        const v = face.constant;
                        // For each midpoint in U and knot in W
                        for (const u of midpointsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                for (const w of knotsW) {
                                    if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'u' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on W-perpendicular meshfaces
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'w') {
                        const w = face.constant;
                        // For each midpoint in U and knot in V
                        for (const u of midpointsU) {
                            if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                for (const v of knotsV) {
                                    if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'u' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (normalAxis === 'v') {
                // Find midpoints in V direction
                const midpointsV = [];
                for (let i = 0; i < knotsV.length - 1; i++) {
                    midpointsV.push((knotsV[i] + knotsV[i + 1]) / 2);
                }
                
                // Look for points on U-perpendicular meshfaces
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'u') {
                        const u = face.constant;
                        for (const v of midpointsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                for (const w of knotsW) {
                                    if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'v' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on W-perpendicular meshfaces
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'w') {
                        const w = face.constant;
                        for (const v of midpointsV) {
                            if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                for (const u of knotsU) {
                                    if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'v' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else { // normalAxis === 'w'
                // Find midpoints in W direction
                const midpointsW = [];
                for (let i = 0; i < knotsW.length - 1; i++) {
                    midpointsW.push((knotsW[i] + knotsW[i + 1]) / 2);
                }
                
                // Look for points on U-perpendicular meshfaces
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'u') {
                        const u = face.constant;
                        for (const w of midpointsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                for (const v of knotsV) {
                                    if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'w' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on V-perpendicular meshfaces
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'v') {
                        const v = face.constant;
                        for (const w of midpointsW) {
                            if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon) {
                                for (const u of knotsU) {
                                    if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon) {
                                        if (!pointExists(u, v, w)) {
                                            points.push({ u, v, w, normalAxis: 'w' });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Add T-junction extension points from existing meshfaces of the selected normalAxis
            // These points are on the edges of meshfaces that don't reach the boundary
            const tJunctionPoints = getTJunctionPoints3D(mesh, normalAxis);
            for (const tjPt of tJunctionPoints) {
                if (!pointExists(tjPt.u, tjPt.v, tjPt.w)) {
                    points.push(tjPt);
                }
            }
            
            // Helper: check if a plane at this constant is "incomplete" (non-tensor-product)
            // i.e., the union of meshfaces on this plane doesn't cover the full domain [0,1]x[0,1]
            const isPlaneIncomplete = (constant) => {
                const facesOnPlane = mesh.meshfaces.filter(f => 
                    f.normalAxis === normalAxis && Math.abs(f.constant - constant) < epsilon
                );
                if (facesOnPlane.length === 0) return false;
                
                // Check if any face doesn't span the full domain
                for (const face of facesOnPlane) {
                    const spans = face.getSpans();
                    if (spans.start1 > epsilon || spans.end1 < 1 - epsilon ||
                        spans.start2 > epsilon || spans.end2 < 1 - epsilon) {
                        return true; // This face is incomplete
                    }
                }
                return false; // All faces span the full domain
            };
            
            // Only add plane corner points on INCOMPLETE planes (non-tensor-product)
            // This allows extending local refinements but doesn't clutter tensor-product planes
            const existingConstants = new Set();
            for (const face of mesh.meshfaces) {
                if (face.normalAxis === normalAxis) {
                    existingConstants.add(face.constant);
                }
            }
            
            for (const constant of existingConstants) {
                // Skip if this plane is already complete (tensor-product)
                if (!isPlaneIncomplete(constant)) continue;
                
                // Find all valid corners on this plane (intersections of perpendicular faces)
                if (normalAxis === 'u') {
                    // For U-normal plane at u=constant, find V-W intersections
                    for (const vFace of mesh.meshfaces) {
                        if (vFace.normalAxis === 'v' && 
                            constant >= vFace.uStart - epsilon && constant <= vFace.uEnd + epsilon) {
                            const v = vFace.constant;
                            for (const wFace of mesh.meshfaces) {
                                if (wFace.normalAxis === 'w' &&
                                    constant >= wFace.uStart - epsilon && constant <= wFace.uEnd + epsilon &&
                                    v >= wFace.vStart - epsilon && v <= wFace.vEnd + epsilon) {
                                    const w = wFace.constant;
                                    // Check this point is within the V-face's W span
                                    if (w >= vFace.wStart - epsilon && w <= vFace.wEnd + epsilon) {
                                        if (!pointExists(constant, v, w)) {
                                            points.push({ u: constant, v, w, normalAxis: 'u', isPlanePoint: true });
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (normalAxis === 'v') {
                    // For V-normal plane at v=constant, find U-W intersections
                    for (const uFace of mesh.meshfaces) {
                        if (uFace.normalAxis === 'u' &&
                            constant >= uFace.vStart - epsilon && constant <= uFace.vEnd + epsilon) {
                            const u = uFace.constant;
                            for (const wFace of mesh.meshfaces) {
                                if (wFace.normalAxis === 'w' &&
                                    constant >= wFace.vStart - epsilon && constant <= wFace.vEnd + epsilon &&
                                    u >= wFace.uStart - epsilon && u <= wFace.uEnd + epsilon) {
                                    const w = wFace.constant;
                                    // Check this point is within the U-face's W span
                                    if (w >= uFace.wStart - epsilon && w <= uFace.wEnd + epsilon) {
                                        if (!pointExists(u, constant, w)) {
                                            points.push({ u, v: constant, w, normalAxis: 'v', isPlanePoint: true });
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else { // normalAxis === 'w'
                    // For W-normal plane at w=constant, find U-V intersections
                    for (const uFace of mesh.meshfaces) {
                        if (uFace.normalAxis === 'u' &&
                            constant >= uFace.wStart - epsilon && constant <= uFace.wEnd + epsilon) {
                            const u = uFace.constant;
                            for (const vFace of mesh.meshfaces) {
                                if (vFace.normalAxis === 'v' &&
                                    constant >= vFace.wStart - epsilon && constant <= vFace.wEnd + epsilon &&
                                    u >= vFace.uStart - epsilon && u <= vFace.uEnd + epsilon) {
                                    const v = vFace.constant;
                                    // Check this point is within the U-face's V span
                                    if (v >= uFace.vStart - epsilon && v <= uFace.vEnd + epsilon) {
                                        if (!pointExists(u, v, constant)) {
                                            points.push({ u, v, w: constant, normalAxis: 'w', isPlanePoint: true });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Get valid end points given a start point for 3D refinement
         * The end point completes the rectangular region of the meshface
         * It must be on an existing meshface that intersects the plane defined by the start point
         */
        const getValidEndPoints3D = (mesh, startPoint) => {
            const epsilon = 1e-10;
            const points = [];
            const { u: startU, v: startV, w: startW, normalAxis } = startPoint;
            
            const pointExists = (u, v, w) => {
                return points.some(p => 
                    Math.abs(p.u - u) < epsilon && 
                    Math.abs(p.v - v) < epsilon && 
                    Math.abs(p.w - w) < epsilon
                );
            };
            
            const knotsU = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
            const knotsV = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            const knotsW = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            
            if (normalAxis === 'u') {
                // The meshface is at u = startU, we need to find valid corners in the V-W plane
                // End point must be different from start in both v and w
                
                // Look for points on V-perpendicular meshfaces at u = startU
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'v' && 
                        startU >= face.uStart - epsilon && startU <= face.uEnd + epsilon) {
                        const v = face.constant;
                        if (Math.abs(v - startV) > epsilon) {
                            for (const w of knotsW) {
                                if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon &&
                                    Math.abs(w - startW) > epsilon) {
                                    if (!pointExists(startU, v, w)) {
                                        points.push({ u: startU, v, w, normalAxis: 'u' });
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Look for points on W-perpendicular meshfaces at u = startU
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'w' && 
                        startU >= face.uStart - epsilon && startU <= face.uEnd + epsilon) {
                        const w = face.constant;
                        if (Math.abs(w - startW) > epsilon) {
                            for (const v of knotsV) {
                                if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon &&
                                    Math.abs(v - startV) > epsilon) {
                                    if (!pointExists(startU, v, w)) {
                                        points.push({ u: startU, v, w, normalAxis: 'u' });
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (normalAxis === 'v') {
                // The meshface is at v = startV, we need to find valid corners in the U-W plane
                
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'u' && 
                        startV >= face.vStart - epsilon && startV <= face.vEnd + epsilon) {
                        const u = face.constant;
                        if (Math.abs(u - startU) > epsilon) {
                            for (const w of knotsW) {
                                if (w >= face.wStart - epsilon && w <= face.wEnd + epsilon &&
                                    Math.abs(w - startW) > epsilon) {
                                    if (!pointExists(u, startV, w)) {
                                        points.push({ u, v: startV, w, normalAxis: 'v' });
                                    }
                                }
                            }
                        }
                    }
                }
                
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'w' && 
                        startV >= face.vStart - epsilon && startV <= face.vEnd + epsilon) {
                        const w = face.constant;
                        if (Math.abs(w - startW) > epsilon) {
                            for (const u of knotsU) {
                                if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon &&
                                    Math.abs(u - startU) > epsilon) {
                                    if (!pointExists(u, startV, w)) {
                                        points.push({ u, v: startV, w, normalAxis: 'v' });
                                    }
                                }
                            }
                        }
                    }
                }
            } else { // normalAxis === 'w'
                // The meshface is at w = startW, we need to find valid corners in the U-V plane
                
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'u' && 
                        startW >= face.wStart - epsilon && startW <= face.wEnd + epsilon) {
                        const u = face.constant;
                        if (Math.abs(u - startU) > epsilon) {
                            for (const v of knotsV) {
                                if (v >= face.vStart - epsilon && v <= face.vEnd + epsilon &&
                                    Math.abs(v - startV) > epsilon) {
                                    if (!pointExists(u, v, startW)) {
                                        points.push({ u, v, w: startW, normalAxis: 'w' });
                                    }
                                }
                            }
                        }
                    }
                }
                
                for (const face of mesh.meshfaces) {
                    if (face.normalAxis === 'v' && 
                        startW >= face.wStart - epsilon && startW <= face.wEnd + epsilon) {
                        const v = face.constant;
                        if (Math.abs(v - startV) > epsilon) {
                            for (const u of knotsU) {
                                if (u >= face.uStart - epsilon && u <= face.uEnd + epsilon &&
                                    Math.abs(u - startU) > epsilon) {
                                    if (!pointExists(u, v, startW)) {
                                        points.push({ u, v, w: startW, normalAxis: 'w' });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return points;
        };

        /**
         * Count B-splines covering each 3D element
         */
        const countBSplinesInElements3D = (bsplines, elements) => {
            return elements.map(element => {
                let count = 0;
                for (const bspline of bsplines) {
                    const support = bspline.getSupport();
                    if (element.isContainedInSupport(support)) {
                        count++;
                    }
                }
                return { element, count };
            });
        };

        /**
         * Get B-splines covering a 3D element
         */
        const getBSplinesCoveringElement3D = (bsplines, element) => {
            return bsplines.filter(bspline => {
                const support = bspline.getSupport();
                return element.isContainedInSupport(support);
            });
        };

        /**
         * Create initial 3D mesh
         */
        const createMesh3D = (degreeU, degreeV, degreeW, numElementsU, numElementsV, numElementsW) => {
            resetBSplineIdCounter();
            
            const knotsU = [], knotsV = [], knotsW = [];
            for (let i = 0; i <= numElementsU; i++) knotsU.push(i / numElementsU);
            for (let i = 0; i <= numElementsV; i++) knotsV.push(i / numElementsV);
            for (let i = 0; i <= numElementsW; i++) knotsW.push(i / numElementsW);
            
            // meshCells stores element-level mesh coverage for each plane
            // Key: "normalAxis_constant" (e.g., "u_0.5")
            // Value: Set of cell keys "span1Start_span1End_span2Start_span2End"
            const meshCells = new Map();
            
            // Create initial tensor-product meshfaces (full coverage on boundary planes)
            // For boundary planes, all element cells are covered
            const meshfaces = [];
            let nextId = 0;
            
            // U-perpendicular faces at each U knot
            for (const u of knotsU) {
                const key = `u_${u.toFixed(10)}`;
                const cells = new Set();
                // Full coverage: all V-W element cells
                for (let j = 0; j < numElementsV; j++) {
                    for (let k = 0; k < numElementsW; k++) {
                        const cellKey = `${knotsV[j]}_${knotsV[j+1]}_${knotsW[k]}_${knotsW[k+1]}`;
                        cells.add(cellKey);
                    }
                }
                meshCells.set(key, cells);
                meshfaces.push(new Meshface('u', u, 0, 1, 0, 1, nextId++));
            }
            
            // V-perpendicular faces at each V knot
            for (const v of knotsV) {
                const key = `v_${v.toFixed(10)}`;
                const cells = new Set();
                // Full coverage: all U-W element cells
                for (let i = 0; i < numElementsU; i++) {
                    for (let k = 0; k < numElementsW; k++) {
                        const cellKey = `${knotsU[i]}_${knotsU[i+1]}_${knotsW[k]}_${knotsW[k+1]}`;
                        cells.add(cellKey);
                    }
                }
                meshCells.set(key, cells);
                meshfaces.push(new Meshface('v', v, 0, 1, 0, 1, nextId++));
            }
            
            // W-perpendicular faces at each W knot
            for (const w of knotsW) {
                const key = `w_${w.toFixed(10)}`;
                const cells = new Set();
                // Full coverage: all U-V element cells
                for (let i = 0; i < numElementsU; i++) {
                    for (let j = 0; j < numElementsV; j++) {
                        const cellKey = `${knotsU[i]}_${knotsU[i+1]}_${knotsV[j]}_${knotsV[j+1]}`;
                        cells.add(cellKey);
                    }
                }
                meshCells.set(key, cells);
                meshfaces.push(new Meshface('w', w, 0, 1, 0, 1, nextId++));
            }
            
            // Create B-splines
            const bsplines = [];
            const numBSplinesU = knotsU.length - degreeU - 1;
            const numBSplinesV = knotsV.length - degreeV - 1;
            const numBSplinesW = knotsW.length - degreeW - 1;
            
            for (let i = 0; i < numBSplinesU; i++) {
                for (let j = 0; j < numBSplinesV; j++) {
                    for (let k = 0; k < numBSplinesW; k++) {
                        bsplines.push(new LRBSpline3D(
                            knotsU.slice(i, i + degreeU + 2),
                            knotsV.slice(j, j + degreeV + 2),
                            knotsW.slice(k, k + degreeW + 2)
                        ));
                    }
                }
            }
            
            // Create elements
            const elements = [];
            for (let i = 0; i < numElementsU; i++) {
                for (let j = 0; j < numElementsV; j++) {
                    for (let k = 0; k < numElementsW; k++) {
                        elements.push(new Element3D(
                            knotsU[i], knotsU[i + 1],
                            knotsV[j], knotsV[j + 1],
                            knotsW[k], knotsW[k + 1]
                        ));
                    }
                }
            }
            
            return {
                meshfaces, bsplines, elements,
                meshCells,  // New: element-level mesh coverage
                degreeU, degreeV, degreeW,
                nextId,
                globalKnotsU: new Set(knotsU),
                globalKnotsV: new Set(knotsV),
                globalKnotsW: new Set(knotsW)
            };
        };

        /**
         * Get all element cells that a meshface region covers
         * Returns array of { span1Start, span1End, span2Start, span2End }
         */
        const getMeshfaceCells = (mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            const cells = [];
            
            // Get the appropriate knot arrays for the two span directions
            let knots1, knots2;
            if (normalAxis === 'u') {
                knots1 = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
                knots2 = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            } else if (normalAxis === 'v') {
                knots1 = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
                knots2 = Array.from(mesh.globalKnotsW).sort((a, b) => a - b);
            } else {
                knots1 = Array.from(mesh.globalKnotsU).sort((a, b) => a - b);
                knots2 = Array.from(mesh.globalKnotsV).sort((a, b) => a - b);
            }
            
            // Find all element cells that overlap with the meshface region
            for (let i = 0; i < knots1.length - 1; i++) {
                const cellStart1 = knots1[i];
                const cellEnd1 = knots1[i + 1];
                
                // Check if this cell overlaps with span1
                if (cellEnd1 <= span1Start + epsilon || cellStart1 >= span1End - epsilon) continue;
                
                for (let j = 0; j < knots2.length - 1; j++) {
                    const cellStart2 = knots2[j];
                    const cellEnd2 = knots2[j + 1];
                    
                    // Check if this cell overlaps with span2
                    if (cellEnd2 <= span2Start + epsilon || cellStart2 >= span2End - epsilon) continue;
                    
                    cells.push({
                        span1Start: cellStart1, span1End: cellEnd1,
                        span2Start: cellStart2, span2End: cellEnd2
                    });
                }
            }
            
            return cells;
        };

        /**
         * Check if mesh cells on a plane fully cover a B-spline's support
         */
        const meshCellsCoverBSpline = (mesh, normalAxis, constant, bspline) => {
            const epsilon = 1e-10;
            const support = bspline.getSupport();
            
            // Check if the constant is strictly inside the B-spline's support
            if (normalAxis === 'u') {
                if (constant <= support.uMin + epsilon || constant >= support.uMax - epsilon) return false;
            } else if (normalAxis === 'v') {
                if (constant <= support.vMin + epsilon || constant >= support.vMax - epsilon) return false;
            } else {
                if (constant <= support.wMin + epsilon || constant >= support.wMax - epsilon) return false;
            }
            
            // Check if the knot already exists in the B-spline
            if (normalAxis === 'u' && countKnotInVector(bspline.knotsU, constant) > 0) return false;
            if (normalAxis === 'v' && countKnotInVector(bspline.knotsV, constant) > 0) return false;
            if (normalAxis === 'w' && countKnotInVector(bspline.knotsW, constant) > 0) return false;
            
            // Get the mesh cells for this plane
            const planeKey = `${normalAxis}_${constant.toFixed(10)}`;
            const cells = mesh.meshCells.get(planeKey);
            if (!cells || cells.size === 0) return false;
            
            // Determine the span ranges we need to cover based on B-spline support
            let span1Min, span1Max, span2Min, span2Max;
            if (normalAxis === 'u') {
                span1Min = support.vMin; span1Max = support.vMax;
                span2Min = support.wMin; span2Max = support.wMax;
            } else if (normalAxis === 'v') {
                span1Min = support.uMin; span1Max = support.uMax;
                span2Min = support.wMin; span2Max = support.wMax;
            } else {
                span1Min = support.uMin; span1Max = support.uMax;
                span2Min = support.vMin; span2Max = support.vMax;
            }
            
            // Find all element cells that need to be covered
            const requiredCells = getMeshfaceCells(mesh, normalAxis, constant, span1Min, span1Max, span2Min, span2Max);
            
            // Check if all required cells are present
            for (const cell of requiredCells) {
                const cellKey = `${cell.span1Start}_${cell.span1End}_${cell.span2Start}_${cell.span2End}`;
                if (!cells.has(cellKey)) {
                    return false;
                }
            }
            
            return true;
        };

        /**
         * Add a meshface and perform refinement
         * This implements a two-step refinement process similar to the LRSplines library:
         * Step 1: Split all existing B-splines that are traversed by the new/merged meshface
         * Step 2: Check if any newly created B-splines need to be split by existing meshfaces
         * Now uses element-level mesh cell storage for clean coverage checks
         */
        const addMeshface = (mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End) => {
            const epsilon = 1e-10;
            const newMesh = { ...mesh };
            
            // Clone the meshCells map
            newMesh.meshCells = new Map(mesh.meshCells);
            
            // Update global knots first (needed for cell calculation)
            if (normalAxis === 'u') newMesh.globalKnotsU = new Set([...mesh.globalKnotsU, constant]);
            else if (normalAxis === 'v') newMesh.globalKnotsV = new Set([...mesh.globalKnotsV, constant]);
            else newMesh.globalKnotsW = new Set([...mesh.globalKnotsW, constant]);
            
            // Get the cells covered by this new meshface
            const newCells = getMeshfaceCells(newMesh, normalAxis, constant, span1Start, span1End, span2Start, span2End);
            
            // Add cells to the mesh cell storage (only new ones)
            const planeKey = `${normalAxis}_${constant.toFixed(10)}`;
            if (!newMesh.meshCells.has(planeKey)) {
                newMesh.meshCells.set(planeKey, new Set());
            }
            const planeCells = newMesh.meshCells.get(planeKey);
            
            let addedAnyCells = false;
            for (const cell of newCells) {
                const cellKey = `${cell.span1Start}_${cell.span1End}_${cell.span2Start}_${cell.span2End}`;
                if (!planeCells.has(cellKey)) {
                    planeCells.add(cellKey);
                    addedAnyCells = true;
                }
            }
            
            // If no new cells were added, nothing to do
            if (!addedAnyCells) {
                return mesh;  // Return original mesh unchanged
            }
            
            // We still maintain meshfaces for visualization, but these are now derived from cells
            // For now, keep the meshface list as-is (we could optimize this later)
            const mergeResult = mergeOrAddMeshface(
                mesh.meshfaces,
                normalAxis,
                constant,
                span1Start,
                span1End,
                span2Start,
                span2End,
                newMesh.nextId
            );
            
            newMesh.meshfaces = mergeResult.meshfaces;
            if (mergeResult.wasNewFace) {
                newMesh.nextId++;
            }
            
            // STEP 1: Split all existing B-splines that have full mesh cell coverage
            let currentBSplines = [...mesh.bsplines];
            let newlyCreated = [];
            let splitBSplineIds = new Set();
            
            for (const bspline of currentBSplines) {
                if (meshCellsCoverBSpline(newMesh, normalAxis, constant, bspline)) {
                    // Create a virtual face spanning the B-spline's support for splitting
                    const support = bspline.getSupport();
                    let virtSpan1Start, virtSpan1End, virtSpan2Start, virtSpan2End;
                    if (normalAxis === 'u') {
                        virtSpan1Start = support.vMin; virtSpan1End = support.vMax;
                        virtSpan2Start = support.wMin; virtSpan2End = support.wMax;
                    } else if (normalAxis === 'v') {
                        virtSpan1Start = support.uMin; virtSpan1End = support.uMax;
                        virtSpan2Start = support.wMin; virtSpan2End = support.wMax;
                    } else {
                        virtSpan1Start = support.uMin; virtSpan1End = support.uMax;
                        virtSpan2Start = support.vMin; virtSpan2End = support.vMax;
                    }
                    const virtualFace = new Meshface(
                        normalAxis, constant,
                        virtSpan1Start, virtSpan1End,
                        virtSpan2Start, virtSpan2End,
                        -1
                    );
                    newlyCreated.push(...splitBSplineByMeshface(bspline, virtualFace));
                    splitBSplineIds.add(bspline.id);
                }
            }
            
            const unsplit = currentBSplines.filter(b => !splitBSplineIds.has(b.id));
            
            // STEP 2: Check if any newly created B-splines need to be split by existing mesh cell coverage
            let splitsOccurred = true;
            while (splitsOccurred) {
                splitsOccurred = false;
                const nextNew = [];
                for (const bspline of newlyCreated) {
                    let wasSplit = false;
                    
                    // Check all planes in meshCells
                    for (const [planeKeyStr, cells] of newMesh.meshCells) {
                        const [axis, constStr] = planeKeyStr.split('_');
                        const constVal = parseFloat(constStr);
                        
                        if (meshCellsCoverBSpline(newMesh, axis, constVal, bspline)) {
                            const support = bspline.getSupport();
                            let virtSpan1Start, virtSpan1End, virtSpan2Start, virtSpan2End;
                            if (axis === 'u') {
                                virtSpan1Start = support.vMin; virtSpan1End = support.vMax;
                                virtSpan2Start = support.wMin; virtSpan2End = support.wMax;
                            } else if (axis === 'v') {
                                virtSpan1Start = support.uMin; virtSpan1End = support.uMax;
                                virtSpan2Start = support.wMin; virtSpan2End = support.wMax;
                            } else {
                                virtSpan1Start = support.uMin; virtSpan1End = support.uMax;
                                virtSpan2Start = support.vMin; virtSpan2End = support.vMax;
                            }
                            const virtualFace = new Meshface(
                                axis, constVal,
                                virtSpan1Start, virtSpan1End,
                                virtSpan2Start, virtSpan2End,
                                -1
                            );
                            nextNew.push(...splitBSplineByMeshface(bspline, virtualFace));
                            wasSplit = true;
                            splitsOccurred = true;
                            break;
                        }
                    }
                    
                    if (!wasSplit) nextNew.push(bspline);
                }
                newlyCreated = nextNew;
            }
            
            newMesh.bsplines = removeDuplicateBSplines3D([...unsplit, ...newlyCreated]);
            
            // Split elements by the new meshface
            const nextElements = [];
            for (const element of mesh.elements) {
                const face = new Meshface(normalAxis, constant, span1Start, span1End, span2Start, span2End, -1);
                nextElements.push(...element.splitByMeshface(face));
            }
            newMesh.elements = nextElements;
            
            return newMesh;
        };

        /**
         * Three.js Visualization Component
         */
        function ThreeVisualization({ 
            mesh, 
            selectedBSpline, 
            showMeshfaces, 
            showGreville, 
            showElements, 
            showBSplineSupports,
            refinementPoints,
            refinementStart,
            onPointClick,
            onGrevilleClick,
            showRefinementPoints,
            inspectionPlane,
            onInspectionClick,
            showInspectionPoints
        }) {
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const controlsRef = useRef(null);
            const clickablePointsRef = useRef([]);
            const grevillePointsRef = useRef([]);
            const inspectionPointsRef = useRef([]);

            useEffect(() => {
                if (!containerRef.current) return;

                // Setup scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                sceneRef.current = scene;

                // Setup camera
                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.set(2, 2, 2);
                cameraRef.current = camera;

                // Setup renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Setup controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.target.set(0.5, 0.5, 0.5);
                controls.update();
                controlsRef.current = controls;

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                // Axes helper removed - bounding box is sufficient

                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();

                // Handle resize
                const handleResize = () => {
                    if (!containerRef.current) return;
                    const w = containerRef.current.clientWidth;
                    const h = containerRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            // Handle click events for refinement points and Greville points
            useEffect(() => {
                if (!rendererRef.current || !cameraRef.current || !sceneRef.current) return;
                
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                const handleClick = (event) => {
                    const rect = rendererRef.current.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, cameraRef.current);
                    
                    // First check refinement points
                    if (showRefinementPoints && clickablePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(clickablePointsRef.current);
                        if (intersects.length > 0) {
                            const clickedPoint = intersects[0].object.userData.pointData;
                            if (clickedPoint && onPointClick) {
                                onPointClick(clickedPoint);
                                return;
                            }
                        }
                    }
                    
                    // Check inspection points
                    if (inspectionPointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(inspectionPointsRef.current);
                        if (intersects.length > 0) {
                            const planeData = intersects[0].object.userData.planeData;
                            if (planeData && onInspectionClick) {
                                onInspectionClick(planeData);
                                return;
                            }
                        }
                    }
                    
                    // Then check Greville points
                    if (showGreville && grevillePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(grevillePointsRef.current);
                        if (intersects.length > 0) {
                            const bsplineId = intersects[0].object.userData.bsplineId;
                            if (bsplineId !== undefined && onGrevilleClick) {
                                onGrevilleClick(bsplineId);
                                return;
                            }
                        }
                    }
                };
                
                const handleMouseMove = (event) => {
                    const rect = rendererRef.current.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, cameraRef.current);
                    
                    // Check refinement points first
                    if (showRefinementPoints && clickablePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(clickablePointsRef.current);
                        if (intersects.length > 0) {
                            rendererRef.current.domElement.style.cursor = 'pointer';
                            return;
                        }
                    }
                    
                    // Check inspection points
                    if (inspectionPointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(inspectionPointsRef.current);
                        if (intersects.length > 0) {
                            rendererRef.current.domElement.style.cursor = 'pointer';
                            return;
                        }
                    }
                    
                    // Then check Greville points
                    if (showGreville && grevillePointsRef.current.length > 0) {
                        const intersects = raycaster.intersectObjects(grevillePointsRef.current);
                        if (intersects.length > 0) {
                            rendererRef.current.domElement.style.cursor = 'pointer';
                            return;
                        }
                    }
                    
                    rendererRef.current.domElement.style.cursor = 'grab';
                };
                
                rendererRef.current.domElement.addEventListener('click', handleClick);
                rendererRef.current.domElement.addEventListener('mousemove', handleMouseMove);
                
                return () => {
                    if (rendererRef.current) {
                        rendererRef.current.domElement.removeEventListener('click', handleClick);
                        rendererRef.current.domElement.removeEventListener('mousemove', handleMouseMove);
                    }
                };
            }, [showRefinementPoints, showGreville, onPointClick, onGrevilleClick, onInspectionClick]);

            // Update visualization when mesh changes
            useEffect(() => {
                if (!sceneRef.current) return;
                const scene = sceneRef.current;

                // Remove old mesh objects
                const toRemove = [];
                scene.traverse(obj => {
                    if (obj.userData.isMeshObject) toRemove.push(obj);
                });
                toRemove.forEach(obj => scene.remove(obj));
                clickablePointsRef.current = [];
                grevillePointsRef.current = [];
                inspectionPointsRef.current = [];

                // Draw bounding box
                const boxGeo = new THREE.BoxGeometry(1, 1, 1);
                const boxEdges = new THREE.EdgesGeometry(boxGeo);
                const boxLines = new THREE.LineSegments(boxEdges, new THREE.LineBasicMaterial({ color: 0x333333 }));
                boxLines.position.set(0.5, 0.5, 0.5);
                boxLines.userData.isMeshObject = true;
                scene.add(boxLines);

                // Draw meshfaces
                if (showMeshfaces) {
                    mesh.meshfaces.forEach(face => {
                        const spans = face.getSpans();
                        let geometry, position;
                        
                        if (face.normalAxis === 'u') {
                            const width = spans.end1 - spans.start1;
                            const height = spans.end2 - spans.start2;
                            geometry = new THREE.PlaneGeometry(width, height);
                            position = new THREE.Vector3(face.constant, (spans.start1 + spans.end1) / 2, (spans.start2 + spans.end2) / 2);
                            geometry.rotateY(Math.PI / 2);
                        } else if (face.normalAxis === 'v') {
                            const width = spans.end1 - spans.start1;
                            const height = spans.end2 - spans.start2;
                            geometry = new THREE.PlaneGeometry(width, height);
                            position = new THREE.Vector3((spans.start1 + spans.end1) / 2, face.constant, (spans.start2 + spans.end2) / 2);
                            geometry.rotateX(-Math.PI / 2);
                        } else {
                            const width = spans.end1 - spans.start1;
                            const height = spans.end2 - spans.start2;
                            geometry = new THREE.PlaneGeometry(width, height);
                            position = new THREE.Vector3((spans.start1 + spans.end1) / 2, (spans.start2 + spans.end2) / 2, face.constant);
                        }
                        
                        const material = new THREE.MeshBasicMaterial({ 
                            color: 0x007acc, 
                            transparent: true, 
                            opacity: inspectionPlane ? 0.03 : 0.1, 
                            side: THREE.DoubleSide 
                        });
                        const plane = new THREE.Mesh(geometry, material);
                        plane.position.copy(position);
                        plane.userData.isMeshObject = true;
                        scene.add(plane);

                        // Add edges
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x007acc,
                            transparent: inspectionPlane ? true : false,
                            opacity: inspectionPlane ? 0.1 : 1.0
                        }));
                        line.position.copy(position);
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    });
                }

                // Draw elements (with transparency during refinement)
                if (showElements) {
                    mesh.elements.forEach(el => {
                        const sizeU = el.uMax - el.uMin;
                        const sizeV = el.vMax - el.vMin;
                        const sizeW = el.wMax - el.wMin;
                        const geo = new THREE.BoxGeometry(sizeU, sizeV, sizeW);
                        const edges = new THREE.EdgesGeometry(geo);
                        const lineMat = new THREE.LineBasicMaterial({ 
                            color: 0x999999,
                            transparent: (refinementStart || inspectionPlane) ? true : false,
                            opacity: (refinementStart || inspectionPlane) ? 0.1 : 1.0
                        });
                        const line = new THREE.LineSegments(edges, lineMat);
                        line.position.set(
                            (el.uMin + el.uMax) / 2,
                            (el.vMin + el.vMax) / 2,
                            (el.wMin + el.wMax) / 2
                        );
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    });
                }

                // Draw B-spline supports (only selected, or all if showBSplineSupports is on)
                // During refinement, make transparent to avoid occluding plane and points
                mesh.bsplines.forEach(bspline => {
                    const support = bspline.getSupport();
                    const isSelected = selectedBSpline === bspline.id;
                    
                    // Only draw if selected, or if showBSplineSupports is on
                    if (!isSelected && !showBSplineSupports) return;
                    
                    const sizeU = support.uMax - support.uMin;
                    const sizeV = support.vMax - support.vMin;
                    const sizeW = support.wMax - support.wMin;
                    
                    if (isSelected) {
                        const geo = new THREE.BoxGeometry(sizeU * 0.998, sizeV * 0.998, sizeW * 0.998);
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: 0xff6600, 
                            transparent: true, 
                            opacity: (refinementStart || inspectionPlane) ? 0.05 : 0.3  // Very faint during refinement or inspection
                        });
                        const box = new THREE.Mesh(geo, mat);
                        box.position.set(
                            (support.uMin + support.uMax) / 2,
                            (support.vMin + support.vMax) / 2,
                            (support.wMin + support.wMax) / 2
                        );
                        box.userData.isMeshObject = true;
                        scene.add(box);

                        const edges = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0xff6600, 
                            linewidth: 2,
                            transparent: true,
                            opacity: (refinementStart || inspectionPlane) ? 0.1 : 1.0  // Faint during refinement or inspection
                        }));
                        line.position.copy(box.position);
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    } else if (showBSplineSupports) {
                        // Unselected supports - very faint outline only
                        const geo = new THREE.BoxGeometry(sizeU * 0.998, sizeV * 0.998, sizeW * 0.998);
                        const edges = new THREE.EdgesGeometry(geo);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x999999, 
                            transparent: true,
                            opacity: inspectionPlane ? 0.05 : 0.2  // Even fainter during inspection
                        }));
                        line.position.set(
                            (support.uMin + support.uMax) / 2,
                            (support.vMin + support.vMax) / 2,
                            (support.wMin + support.wMax) / 2
                        );
                        line.userData.isMeshObject = true;
                        scene.add(line);
                    }
                });

                // Draw Greville points (clickable to select B-spline)
                if (showGreville) {
                    const sphereGeo = new THREE.SphereGeometry(0.015, 16, 16);
                    mesh.bsplines.forEach(bspline => {
                        const greville = bspline.getGrevillePoint();
                        const isSelected = selectedBSpline === bspline.id;
                        const mat = new THREE.MeshBasicMaterial({ color: isSelected ? 0xff0000 : 0x28a745 });
                        const sphere = new THREE.Mesh(sphereGeo, mat);
                        sphere.position.set(greville.u, greville.v, greville.w);
                        sphere.userData.isMeshObject = true;
                        sphere.userData.isGrevillePoint = true;
                        sphere.userData.bsplineId = bspline.id;
                        scene.add(sphere);
                        grevillePointsRef.current.push(sphere);
                    });
                }

                // Draw preview plane when start point is selected (before refinement points)
                if (refinementStart) {
                    const { u, v, w, normalAxis } = refinementStart;
                    let geometry, position;
                    
                    if (normalAxis === 'u') {
                        geometry = new THREE.PlaneGeometry(1, 1);
                        geometry.rotateY(Math.PI / 2);
                        position = new THREE.Vector3(u, 0.5, 0.5);
                    } else if (normalAxis === 'v') {
                        geometry = new THREE.PlaneGeometry(1, 1);
                        geometry.rotateX(-Math.PI / 2);
                        position = new THREE.Vector3(0.5, v, 0.5);
                    } else {
                        geometry = new THREE.PlaneGeometry(1, 1);
                        position = new THREE.Vector3(0.5, 0.5, w);
                    }
                    
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x007acc,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.position.copy(position);
                    plane.userData.isMeshObject = true;
                    plane.renderOrder = 1500;  // Higher than B-spline surfaces
                    scene.add(plane);
                    
                    // Add dashed outline
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMat = new THREE.LineDashedMaterial({ 
                        color: 0x007acc, 
                        dashSize: 0.05, 
                        gapSize: 0.02 
                    });
                    const line = new THREE.LineSegments(edges, lineMat);
                    line.computeLineDistances();
                    line.position.copy(position);
                    line.userData.isMeshObject = true;
                    line.renderOrder = 1500;  // Higher than B-spline surfaces
                    scene.add(line);
                    
                    // Add grid lines showing element intersections with the plane
                    // Draw actual element edges that intersect the refinement plane
                    const gridLineMat = new THREE.LineBasicMaterial({ 
                        color: 0x0056a3,  // Darker blue
                        linewidth: 2,
                        depthTest: false  // Always visible on top
                    });
                    const gridPoints = [];
                    const epsilon = 1e-10;
                    
                    // Find elements that the plane passes through and draw their edges
                    mesh.elements.forEach(el => {
                        if (normalAxis === 'u') {
                            // Plane at constant U: check if element spans this U value
                            if (u >= el.uMin - epsilon && u <= el.uMax + epsilon) {
                                // Draw the 4 edges of this element's face in the V-W plane
                                // Bottom edge (vMin)
                                gridPoints.push(new THREE.Vector3(u, el.vMin, el.wMin));
                                gridPoints.push(new THREE.Vector3(u, el.vMin, el.wMax));
                                // Top edge (vMax)
                                gridPoints.push(new THREE.Vector3(u, el.vMax, el.wMin));
                                gridPoints.push(new THREE.Vector3(u, el.vMax, el.wMax));
                                // Left edge (wMin)
                                gridPoints.push(new THREE.Vector3(u, el.vMin, el.wMin));
                                gridPoints.push(new THREE.Vector3(u, el.vMax, el.wMin));
                                // Right edge (wMax)
                                gridPoints.push(new THREE.Vector3(u, el.vMin, el.wMax));
                                gridPoints.push(new THREE.Vector3(u, el.vMax, el.wMax));
                            }
                        } else if (normalAxis === 'v') {
                            // Plane at constant V: check if element spans this V value
                            if (v >= el.vMin - epsilon && v <= el.vMax + epsilon) {
                                // Draw the 4 edges of this element's face in the U-W plane
                                // Bottom edge (uMin)
                                gridPoints.push(new THREE.Vector3(el.uMin, v, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMin, v, el.wMax));
                                // Top edge (uMax)
                                gridPoints.push(new THREE.Vector3(el.uMax, v, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMax, v, el.wMax));
                                // Left edge (wMin)
                                gridPoints.push(new THREE.Vector3(el.uMin, v, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMax, v, el.wMin));
                                // Right edge (wMax)
                                gridPoints.push(new THREE.Vector3(el.uMin, v, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMax, v, el.wMax));
                            }
                        } else {
                            // Plane at constant W: check if element spans this W value
                            if (w >= el.wMin - epsilon && w <= el.wMax + epsilon) {
                                // Draw the 4 edges of this element's face in the U-V plane
                                // Bottom edge (uMin)
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMin, w));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMax, w));
                                // Top edge (uMax)
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMin, w));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMax, w));
                                // Left edge (vMin)
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMin, w));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMin, w));
                                // Right edge (vMax)
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMax, w));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMax, w));
                            }
                        }
                    });
                    
                    const gridGeometry = new THREE.BufferGeometry().setFromPoints(gridPoints);
                    const gridLines = new THREE.LineSegments(gridGeometry, gridLineMat);
                    gridLines.userData.isMeshObject = true;
                    gridLines.renderOrder = 1501;  // Higher than refinement plane
                    scene.add(gridLines);
                }

                // Draw refinement points LAST so they're always on top (most important when active)
                if (showRefinementPoints && refinementPoints && refinementPoints.length > 0) {
                    const pointSphereGeo = new THREE.SphereGeometry(0.012, 12, 12);
                    refinementPoints.forEach((point, idx) => {
                        const isStartPoint = refinementStart && 
                            Math.abs(point.u - refinementStart.u) < 1e-10 &&
                            Math.abs(point.v - refinementStart.v) < 1e-10 &&
                            Math.abs(point.w - refinementStart.w) < 1e-10;
                        
                        // Simple color scheme: blue for available points, red for selected
                        const color = isStartPoint ? 0xdc3545 : 0x007acc;
                        
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: color,
                            transparent: true,
                            opacity: isStartPoint ? 1.0 : 0.7,
                            depthTest: false  // Always render on top
                        });
                        const sphere = new THREE.Mesh(pointSphereGeo, mat);
                        sphere.position.set(point.u, point.v, point.w);
                        sphere.userData.isMeshObject = true;
                        sphere.userData.pointData = point;
                        sphere.userData.isClickable = true;
                        sphere.renderOrder = 1000;  // Highest priority
                        scene.add(sphere);
                        clickablePointsRef.current.push(sphere);
                    });
                    
                    // Also draw the start point if set (extra emphasis)
                    if (refinementStart) {
                        const startMat = new THREE.MeshBasicMaterial({ 
                            color: 0xdc3545,
                            depthTest: false
                        });
                        const startSphere = new THREE.Mesh(pointSphereGeo, startMat);
                        startSphere.position.set(refinementStart.u, refinementStart.v, refinementStart.w);
                        startSphere.userData.isMeshObject = true;
                        startSphere.renderOrder = 1001;  // Even higher than other refinement points
                        scene.add(startSphere);
                    }
                }

                // Draw inspection points outside the cube (one for each unique constant per axis)
                if (showInspectionPoints) {
                    const inspectionOffset = -0.04;
                    const inspSphereGeo = new THREE.SphereGeometry(0.009, 12, 12);
                    
                    // Get unique constants for each axis
                    const uniqueU = new Set(), uniqueV = new Set(), uniqueW = new Set();
                    for (const face of mesh.meshfaces) {
                        if (face.normalAxis === 'u') uniqueU.add(face.constant);
                        else if (face.normalAxis === 'v') uniqueV.add(face.constant);
                        else uniqueW.add(face.constant);
                    }
                    
                    // Draw U-normal plane inspection points at (u, offset, offset)
                    for (const u of uniqueU) {
                    const isSelected = inspectionPlane && inspectionPlane.normalAxis === 'u' && Math.abs(inspectionPlane.constant - u) < 1e-10;
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: isSelected ? 0xffc107 : 0xaaaaaa,  // Yellow if selected, red otherwise
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(inspSphereGeo, mat);
                    sphere.position.set(u, inspectionOffset, inspectionOffset);
                    sphere.userData.isMeshObject = true;
                    sphere.userData.planeData = { normalAxis: 'u', constant: u };
                    scene.add(sphere);
                    inspectionPointsRef.current.push(sphere);
                }
                
                // Draw V-normal plane inspection points at (offset, v, offset)
                for (const v of uniqueV) {
                    const isSelected = inspectionPlane && inspectionPlane.normalAxis === 'v' && Math.abs(inspectionPlane.constant - v) < 1e-10;
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: isSelected ? 0xffc107 : 0xaaaaaa,  // Yellow if selected, green otherwise
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(inspSphereGeo, mat);
                    sphere.position.set(inspectionOffset, v, inspectionOffset);
                    sphere.userData.isMeshObject = true;
                    sphere.userData.planeData = { normalAxis: 'v', constant: v };
                    scene.add(sphere);
                    inspectionPointsRef.current.push(sphere);
                }
                
                // Draw W-normal plane inspection points at (offset, offset, w)
                for (const w of uniqueW) {
                    const isSelected = inspectionPlane && inspectionPlane.normalAxis === 'w' && Math.abs(inspectionPlane.constant - w) < 1e-10;
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: isSelected ? 0xffc107 : 0xaaaaaa,  // Yellow if selected, blue otherwise
                        transparent: true,
                        opacity: 0.9
                    });
                    const sphere = new THREE.Mesh(inspSphereGeo, mat);
                    sphere.position.set(inspectionOffset, inspectionOffset, w);
                    sphere.userData.isMeshObject = true;
                    sphere.userData.planeData = { normalAxis: 'w', constant: w };
                    scene.add(sphere);
                    inspectionPointsRef.current.push(sphere);
                }
                }
                
                // Draw inspection plane with actual meshface coverage (element-level cells)
                if (inspectionPlane) {
                    const { normalAxis, constant } = inspectionPlane;
                    const epsilon = 1e-10;
                    
                    // Get mesh cells for this plane
                    const planeKey = `${normalAxis}_${constant.toFixed(10)}`;
                    const cells = mesh.meshCells ? mesh.meshCells.get(planeKey) : null;
                    
                    // Draw semi-transparent plane background
                    const planeMat = new THREE.MeshBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    
                    let planeGeo;
                    if (normalAxis === 'u') {
                        planeGeo = new THREE.PlaneGeometry(1, 1);
                        planeGeo.rotateY(Math.PI / 2);
                        planeGeo.translate(constant, 0.5, 0.5);
                    } else if (normalAxis === 'v') {
                        planeGeo = new THREE.PlaneGeometry(1, 1);
                        planeGeo.rotateX(-Math.PI / 2);
                        planeGeo.translate(0.5, constant, 0.5);
                    } else {
                        planeGeo = new THREE.PlaneGeometry(1, 1);
                        planeGeo.translate(0.5, 0.5, constant);
                    }
                    
                    const planeMesh = new THREE.Mesh(planeGeo, planeMat);
                    planeMesh.userData.isMeshObject = true;
                    planeMesh.renderOrder = 100;
                    scene.add(planeMesh);
                    
                    // Draw each mesh cell as a filled rectangle (shaded)
                    // Now using element-level cells to avoid double-counting
                    if (cells) {
                        const faceMat = new THREE.MeshBasicMaterial({
                            color: 0x4CAF50,  // Green for covered area
                            transparent: true,
                            opacity: 0.5,
                            side: THREE.DoubleSide,
                            depthWrite: false
                        });
                        
                        for (const cellKey of cells) {
                            // Parse cell key: "span1Start_span1End_span2Start_span2End"
                            const parts = cellKey.split('_').map(parseFloat);
                            const span1Start = parts[0];
                            const span1End = parts[1];
                            const span2Start = parts[2];
                            const span2End = parts[3];
                            
                            const width = span1End - span1Start;
                            const height = span2End - span2Start;
                            
                            let faceGeo;
                            if (normalAxis === 'u') {
                                // V-W plane
                                faceGeo = new THREE.PlaneGeometry(height, width);  // Note: swapped for correct orientation
                                faceGeo.rotateY(Math.PI / 2);
                                faceGeo.translate(constant, span1Start + width/2, span2Start + height/2);
                            } else if (normalAxis === 'v') {
                                // U-W plane
                                faceGeo = new THREE.PlaneGeometry(width, height);
                                faceGeo.rotateX(-Math.PI / 2);
                                faceGeo.translate(span1Start + width/2, constant, span2Start + height/2);
                            } else {
                                // U-V plane
                                faceGeo = new THREE.PlaneGeometry(width, height);
                                faceGeo.translate(span1Start + width/2, span2Start + height/2, constant);
                            }
                            
                            const faceMesh = new THREE.Mesh(faceGeo, faceMat);
                            faceMesh.userData.isMeshObject = true;
                            faceMesh.renderOrder = 101;
                            scene.add(faceMesh);
                        }
                    }
                    
                    // Draw element grid lines on the inspection plane
                    const gridLineMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
                    const gridPoints = [];
                    
                    mesh.elements.forEach(el => {
                        if (normalAxis === 'u') {
                            if (constant >= el.uMin - epsilon && constant <= el.uMax + epsilon) {
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMax));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMax));
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMin));
                                gridPoints.push(new THREE.Vector3(constant, el.vMin, el.wMax));
                                gridPoints.push(new THREE.Vector3(constant, el.vMax, el.wMax));
                            }
                        } else if (normalAxis === 'v') {
                            if (constant >= el.vMin - epsilon && constant <= el.vMax + epsilon) {
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMin));
                                gridPoints.push(new THREE.Vector3(el.uMin, constant, el.wMax));
                                gridPoints.push(new THREE.Vector3(el.uMax, constant, el.wMax));
                            }
                        } else {
                            if (constant >= el.wMin - epsilon && constant <= el.wMax + epsilon) {
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMax, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMax, constant));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMin, constant));
                                gridPoints.push(new THREE.Vector3(el.uMin, el.vMax, constant));
                                gridPoints.push(new THREE.Vector3(el.uMax, el.vMax, constant));
                            }
                        }
                    });
                    
                    if (gridPoints.length > 0) {
                        const gridGeometry = new THREE.BufferGeometry().setFromPoints(gridPoints);
                        const gridLines = new THREE.LineSegments(gridGeometry, gridLineMat);
                        gridLines.userData.isMeshObject = true;
                        gridLines.renderOrder = 102;
                        scene.add(gridLines);
                    }
                }

            }, [mesh, selectedBSpline, showMeshfaces, showGreville, showElements, showBSplineSupports, refinementPoints, refinementStart, showRefinementPoints, inspectionPlane, showInspectionPoints]);

            return <div ref={containerRef} id="threejs-canvas" />;
        }

        /**
         * Main App Component
         */
        function App() {
            const [degreeU, setDegreeU] = useState(2);
            const [degreeV, setDegreeV] = useState(2);
            const [degreeW, setDegreeW] = useState(2);
            const [numElementsU, setNumElementsU] = useState(3);
            const [numElementsV, setNumElementsV] = useState(3);
            const [numElementsW, setNumElementsW] = useState(3);
            const [mesh, setMesh] = useState(() => createMesh3D(2, 2, 2, 3, 3, 3));
            const [selectedBSpline, setSelectedBSpline] = useState(null);
            
            // Visualization toggles
            const [showMeshfaces, setShowMeshfaces] = useState(false);
            const [showGreville, setShowGreville] = useState(true);
            const [showElements, setShowElements] = useState(true);
            const [showBSplineSupports, setShowBSplineSupports] = useState(false);
            const [showRefinementControls, setShowRefinementControls] = useState(false);
            const [showInspectionPoints, setShowInspectionPoints] = useState(false);
            
            // Inspection plane state (for debugging meshface coverage)
            const [inspectionPlane, setInspectionPlane] = useState(null);
            
            // Refinement state
            const [refAxis, setRefAxis] = useState('u');
            const [refinementStart, setRefinementStart] = useState(null);

            // Compute valid points based on current state
            const validStartPoints = useMemo(() => getValidStartPoints3D(mesh, refAxis), [mesh, refAxis]);
            const validEndPoints = useMemo(() => (
                refinementStart ? getValidEndPoints3D(mesh, refinementStart) : []
            ), [mesh, refinementStart]);
            
            // Filter points by selected B-spline if one is selected
            const filterPointsByBSpline = (points) => {
                if (!selectedBSpline) return points;
                const bspline = mesh.bsplines.find(b => b.id === selectedBSpline);
                if (!bspline) return points;
                const support = bspline.getSupport();
                const epsilon = 1e-10;
                return points.filter(p => 
                    p.u >= support.uMin - epsilon && p.u <= support.uMax + epsilon &&
                    p.v >= support.vMin - epsilon && p.v <= support.vMax + epsilon &&
                    p.w >= support.wMin - epsilon && p.w <= support.wMax + epsilon
                );
            };
            
            // Current points to display (filtered by B-spline if selected)
            const refinementPoints = useMemo(() => {
                const points = refinementStart ? validEndPoints : validStartPoints;
                return filterPointsByBSpline(points);
            }, [refinementStart, validStartPoints, validEndPoints, selectedBSpline, mesh]);

            const handleReset = () => {
                setMesh(createMesh3D(degreeU, degreeV, degreeW, numElementsU, numElementsV, numElementsW));
                setSelectedBSpline(null);
                setRefinementStart(null);
            };

            const handleAxisChange = (axis) => {
                setRefAxis(axis);
                setRefinementStart(null);
            };

            const handlePointClick = (point) => {
                if (!refinementStart) {
                    // Set start point
                    setRefinementStart(point);
                    return;
                }
                
                // We have start and now end - add the meshface
                const { normalAxis } = refinementStart;
                let span1Start, span1End, span2Start, span2End;
                let constant;
                
                if (normalAxis === 'u') {
                    constant = refinementStart.u;
                    span1Start = Math.min(refinementStart.v, point.v);
                    span1End = Math.max(refinementStart.v, point.v);
                    span2Start = Math.min(refinementStart.w, point.w);
                    span2End = Math.max(refinementStart.w, point.w);
                } else if (normalAxis === 'v') {
                    constant = refinementStart.v;
                    span1Start = Math.min(refinementStart.u, point.u);
                    span1End = Math.max(refinementStart.u, point.u);
                    span2Start = Math.min(refinementStart.w, point.w);
                    span2End = Math.max(refinementStart.w, point.w);
                } else {
                    constant = refinementStart.w;
                    span1Start = Math.min(refinementStart.u, point.u);
                    span1End = Math.max(refinementStart.u, point.u);
                    span2Start = Math.min(refinementStart.v, point.v);
                    span2End = Math.max(refinementStart.v, point.v);
                }
                
                const newMesh = addMeshface(mesh, normalAxis, constant, span1Start, span1End, span2Start, span2End);
                setMesh(newMesh);
                setRefinementStart(null);
                setSelectedBSpline(null);
            };

            const handleCancelRefinement = () => {
                setRefinementStart(null);
            };
            
            const handleInspectionClick = (planeData) => {
                // Toggle inspection plane - click same plane to dismiss
                if (inspectionPlane && 
                    inspectionPlane.normalAxis === planeData.normalAxis &&
                    Math.abs(inspectionPlane.constant - planeData.constant) < 1e-10) {
                    setInspectionPlane(null);
                } else {
                    setInspectionPlane(planeData);
                }
            };

            const minElements = (deg) => deg + 1;

            return (
                <div className="container">
                    <div className="controls">
                        <h2>LR B-Spline 3D</h2>
                        
                        <div className="info">
                            Click Greville (green) to select B-splines. Click colored points outside cube to inspect meshface coverage on each plane.
                        </div>

                        <div className="stats">
                            <strong>Statistics:</strong><br />
                            B-splines: {mesh.bsplines.length}<br />
                            Meshfaces: {mesh.meshfaces.length}<br />
                            Elements: {mesh.elements.length}
                        </div>

                        <div className="control-group">
                            <label>Degree U: {degreeU}</label>
                            <input type="range" min="1" max="3" value={degreeU} 
                                onChange={(e) => setDegreeU(parseInt(e.target.value))} />
                            <label>Degree V: {degreeV}</label>
                            <input type="range" min="1" max="3" value={degreeV} 
                                onChange={(e) => setDegreeV(parseInt(e.target.value))} />
                            <label>Degree W: {degreeW}</label>
                            <input type="range" min="1" max="3" value={degreeW} 
                                onChange={(e) => setDegreeW(parseInt(e.target.value))} />
                        </div>

                        <div className="control-group">
                            <label>Elements U: {numElementsU}</label>
                            <input type="range" min={minElements(degreeU)} max="6" value={numElementsU} 
                                onChange={(e) => setNumElementsU(parseInt(e.target.value))} />
                            <label>Elements V: {numElementsV}</label>
                            <input type="range" min={minElements(degreeV)} max="6" value={numElementsV} 
                                onChange={(e) => setNumElementsV(parseInt(e.target.value))} />
                            <label>Elements W: {numElementsW}</label>
                            <input type="range" min={minElements(degreeW)} max="6" value={numElementsW} 
                                onChange={(e) => setNumElementsW(parseInt(e.target.value))} />
                        </div>

                        <button onClick={handleReset}>Reset Mesh</button>

                        <div className="control-group">
                            <button 
                                onClick={() => setShowRefinementControls(!showRefinementControls)}
                                style={{ 
                                    background: showRefinementControls ? '#28a745' : '#6c757d',
                                    marginBottom: showRefinementControls ? '10px' : '0'
                                }}>
                                {showRefinementControls ? ' Refinement Mode (Active)' : ' Refinement Mode'}
                            </button>
                            
                            {showRefinementControls && (
                                <div style={{ 
                                    background: '#f8f9fa', 
                                    padding: '10px', 
                                    borderRadius: '4px',
                                    border: '1px solid #28a745'
                                }}>
                                    <div style={{ fontSize: '12px', color: '#28a745', marginBottom: '8px' }}>
                                        {refinementStart 
                                            ? `Click end point to complete ${refAxis.toUpperCase()}-perp meshface`
                                            : `Click a blue point to start refinement`
                                        }
                                    </div>
                                    
                                    <label style={{ fontSize: '12px' }}>Direction (normal axis):</label>
                                    <div style={{ display: 'flex', gap: '5px', marginBottom: '8px' }}>
                                        {['u', 'v', 'w'].map(axis => (
                                            <button key={axis} 
                                                style={{ 
                                                    flex: 1, 
                                                    background: refAxis === axis ? '#005a9e' : '#007acc',
                                                    fontSize: '12px',
                                                    padding: '5px'
                                                }}
                                                onClick={() => handleAxisChange(axis)}>
                                                {axis.toUpperCase()}-perp
                                            </button>
                                        ))}
                                    </div>
                                    
                                    {refinementStart && (
                                        <div style={{ marginBottom: '8px' }}>
                                            <div style={{ fontSize: '11px', marginBottom: '5px' }}>
                                                Start: ({refinementStart.u.toFixed(2)}, {refinementStart.v.toFixed(2)}, {refinementStart.w.toFixed(2)})
                                            </div>
                                            <button onClick={handleCancelRefinement} style={{ background: '#dc3545', fontSize: '12px' }}>
                                                Cancel
                                            </button>
                                        </div>
                                    )}
                                    
                                    <div style={{ fontSize: '10px', color: '#666' }}>
                                        Available points: {refinementPoints.length}
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="control-group">
                            <label>Display Options:</label>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showMeshfaces" checked={showMeshfaces} 
                                    onChange={(e) => setShowMeshfaces(e.target.checked)} />
                                <label htmlFor="showMeshfaces">Meshfaces</label>
                            </div>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showGreville" checked={showGreville} 
                                    onChange={(e) => setShowGreville(e.target.checked)} />
                                <label htmlFor="showGreville">Greville Points</label>
                            </div>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showElements" checked={showElements} 
                                    onChange={(e) => setShowElements(e.target.checked)} />
                                <label htmlFor="showElements">Elements</label>
                            </div>
                            <div className="checkbox-group">
                                <input type="checkbox" id="showSupports" checked={showBSplineSupports} 
                                    onChange={(e) => setShowBSplineSupports(e.target.checked)} />
                                <label htmlFor="showSupports">B-spline Supports</label>
                            </div>
                        </div>

                        <div className="control-group">
                            <button 
                                onClick={() => {
                                    const newState = !showInspectionPoints;
                                    setShowInspectionPoints(newState);
                                    if (!newState) {
                                        setInspectionPlane(null);
                                    }
                                }}
                                style={{ 
                                    background: showInspectionPoints ? '#ffc107' : '#6c757d',
                                    marginBottom: showInspectionPoints ? '10px' : '0'
                                }}>
                                {showInspectionPoints ? ' Inspection Mode (Active)' : ' Inspection Mode'}
                            </button>
                            
                            {showInspectionPoints && inspectionPlane && (
                                <div style={{ 
                                    background: '#fff8e1', 
                                    padding: '10px', 
                                    borderRadius: '4px',
                                    border: '1px solid #ffc107',
                                    marginBottom: '10px'
                                }}>
                                    <div style={{ fontSize: '12px', color: '#666' }}>
                                        Inspecting {inspectionPlane.normalAxis.toUpperCase()}-plane at {inspectionPlane.constant.toFixed(3)}
                                    </div>
                                    <button 
                                        onClick={() => setInspectionPlane(null)}
                                        style={{ 
                                            fontSize: '12px', 
                                            padding: '4px 8px',
                                            marginTop: '5px'
                                        }}>
                                        Clear Plane
                                    </button>
                                </div>
                            )}
                        </div>

                        <div className="control-group">
                            <label>B-splines (click to select):</label>
                            <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
                                {mesh.bsplines.map(bspline => (
                                    <div key={bspline.id}
                                        className={`bspline-item ${selectedBSpline === bspline.id ? 'selected' : ''}`}
                                        onClick={() => setSelectedBSpline(selectedBSpline === bspline.id ? null : bspline.id)}>
                                        u:[{bspline.knotsU.map(k => k.toFixed(2)).join(',')}]<br/>
                                        v:[{bspline.knotsV.map(k => k.toFixed(2)).join(',')}]<br/>
                                        w:[{bspline.knotsW.map(k => k.toFixed(2)).join(',')}]
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="visualization">
                        <ThreeVisualization 
                            mesh={mesh}
                            selectedBSpline={selectedBSpline}
                            showMeshfaces={showMeshfaces}
                            showGreville={showGreville}
                            showElements={showElements}
                            showBSplineSupports={showBSplineSupports}
                            refinementPoints={refinementPoints}
                            refinementStart={refinementStart}
                            onPointClick={handlePointClick}
                            onGrevilleClick={(id) => {
                                if (selectedBSpline === id) {
                                    setSelectedBSpline(null);
                                } else {
                                    setSelectedBSpline(id);
                                    setShowBSplineSupports(true);
                                }
                            }}
                            showRefinementPoints={showRefinementControls}
                            inspectionPlane={inspectionPlane}
                            onInspectionClick={handleInspectionClick}
                            showInspectionPoints={showInspectionPoints}
                        />
                    </div>
                </div>
            );
        }

        // Wait for THREE to be loaded before rendering
        const renderApp = () => {
            ReactDOM.render(<App />, document.getElementById('root'));
        };
        
        if (window.THREE) {
            renderApp();
        } else {
            window.addEventListener('three-loaded', renderApp);
        }
    </script>
</body>
</html>